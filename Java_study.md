# プログラムの書き方  

## Javaプログラム作成から実行までの手順  
- ファイルの作成  
  ・テキストエディタで新しいファイルを作成し、拡張子を.javaとして保存  
  ・クラス名はアルファベット大文字で始める  
- Javaファイルを開き、Javaプログラムを記述  
  ・1行目のpublic classの後はクラス名を記述する。Javaのルールとしてファイル名は「クラス名.java」にしなければならない  
  ・2行目のpublic static void main(String[] args) {}の{}内に入力した記述が出力される  
  ・コード例  
    public class MyProgram {  
  　 public static void main(String[] args) {  
  　　 System.out.println("Hello, World!");  
  　 }  
   }  
- コンパイル  
  ・ターミナルまたはコマンドプロンプトを開き、Javaファイルが保存されているディレクトリに移動する  
  ・javacコマンド(javac クラス名.java)を使用してJavaファイルをコンパイルする  
- 実行  
  ・コンパイルが成功したら、javaコマンド(java クラス名)を使用してプログラムを実行する  

## Java プロジェクトの基本構造  
- プログラムの骨格  
  ・{}で囲まれた部分をブロックと呼ぶ。外側のブロックをクラスブロック、内側のブロックをメソッドブロックと呼び、Javaのソースコードはこれらのブロックによる二重構造を持っている  
  ・ Javaの命令を書くのはメソッドブロックの内側
- コメントの記入  
  ・複数行コメント  
  　/* コメント本文(複数行でも可能) */  
  ・単一行コメント  
  　//コメント本文(行末まで)  
- mainメソッドの内容  
  ・プログラム実行時は、文は上から順に1行ずつ処理される  
  ・分の末尾には必ずセミコロン(;)を付ける  
  ・ ()に入力するのが文字の時は""で挟む、数字の時は不要  
- 変数宣言の文  
  ・変数を使う時は、まず「変数宣言の文」を使い変数を使う宣言をする必要がある  
  ・変数宣言の文  
  　型 変数名;  
例) int = age  
  ・変数を宣言するときに使える名前のことを識別子といい、アルファベットや数字、アンダースコア(_)、ドル記号($)などを組み合わせて作る。  
 　 注意)intやvoid、public、staticなどの予約語は変数として使えない。小文字から始まる名詞形の名前を付ける(複数の単語を繋げて変数にする場合、2つ目以降の単語を大文字にする)  
- データ型  
　分類　　型名　　　格納するデータ  
　整数　　byte　　　とても小さな整数(±約128)  
　　　　　short　　　小さな整数(±約3.2万)  
　　　　　int　　　　普通の整数(±約21億)  
　　　　　long　　　大きな整数(±約900京)  
　少数　　float　　　少しあいまいでもよい少数  
　　　　　double　　普通の少数  
　真偽値　boolean　 tureかfalse  
　文字　　char　　　 1つの文字  
　文字列　String　　 文字の並び  

　　・整数を格納したい場合、int型を使うことが多い  
　　・少数を格納したい場合、より厳密な計算が行えるdoubleを使うことが多い、金額の計算など誤差が許されない計算の時はfloatやdoubleを使わない  
　　・boolean型は、「YESかNOか」「本当か嘘か」などの二者択一の情報を代入する時に使う、肯定的な情報はtrue、否定的な情報はfalse  
　　・char型は全角/半角を問わず1文字だけ代入できる、String型は文字列(0文字以上の文字の集まり)を代入できる。文字データを記述する場合は引用符(')で、文字列データを記述する場合は二重引用符(")を使う  

- 変数の初期化  
・変数を宣言すると同時に値を代入することを、変数の初期化という  
　　型 変数名 = 代入するデータ;
例) int age = 22;  
- 定数の宣言
・finalを付けて宣言された変数は定数として扱われ、値は書き換えられない(定数名はすべて大文字を用いる)
　　final 型　定数名 = 初期値;
例) final double PI = 3.14;

## 式と演算子  
- リテラル  
・ソースコードに記述されている数値や文字列などの具体的な値をリテラルという  
- エスケープシーケンス  
・String型やchar型のリテラルを記述する際に、ときどき用いられるものをエスケープシーケンスという、¥記号とそれに続く1文字からなる表記
  Javaは2つの二重引用符に囲まれた部分を文字列リテラルと見なすから、文字列の途中で改行する時や、記号を画面に表示する時などに使う  
　表記　　意味  
　¥"　　　二重引用符記号(")  
　¥'　　　引用符記号(')  
　¥¥　　　円記号(¥)  
　¥n　　　改行(制御文字)  
- 命令実行の文  
・命令実行の文  
　呼び出す命令の名前(引数);  
例) System.out.println(message);  
- 画面に文字を表示する  
・改行せずに画面に文字を表示する  
　System.out.print(①);　　①には画面に表示したい値や指揮を指定する  
- 大きいほうの数値を代入する命令  
・2つの値を比較して大きい方の数値を代入する  
　int m = Math.max(①,②);　　①および②には比較したい値や式を指定する(代入する変数名はm以外の名前でも可)  
　例)int a = 5;  
　　 int b = 3;  
  　　 int m = Math.max(a,b);  
- 文字列を整数に変換する命令  
・文字列を整数を変換する  
　int n = Integer.parseInt(①);  
- 乱数を生み出して代入する命令  
・乱数を発生させる  
　int r = new java.utilRandom().nextInt(①);　　①には発生させる乱数の上限値(指定値事態を含まない)を指定する  
　①に10を指定するとrには0~9のいずれかが代入される  
-　キーボードから1行の入力を受け取る命令  
・キーボードから1行の文字列の入力を受け付ける  
　String s = new java.util.Scanner(System.in).nextLine();  
・キーボードから1つの整数の入力を受け付ける  
　int input = new java.util.Scanner(System.in).nextInt();  
　これらの文を実行すると、プログラムは一時停止し利用者がキーボードから文字を入力できるようになる。入力した内容が各変数に代入される  

## 条件分岐と繰り返し  
- 代表的な制御構造  
　順次　　　単純に次の文を実行する  
　分岐　　　条件によって違う文を実行する  
　繰り返し　条件が満たされるまで同じ分を繰り返す  
・分岐  if文  
　if (分岐条件) ｛  
　　条件成立のときに実行する処理  
  　} else {  
  　　条件不成立のときに実行する処理  
  　}  
・繰り返し　While文  
　while (繰り返しを続ける条件) {  
　　繰り返し実行する処理  
　}  
・制御構文  
　if文やwhile文のような制御構造を表す分のこと 、条件式とブロックで成り立つ  
　条件式　　分岐条件や繰り返しを続ける条件を示した式  
　ブロック　分岐や繰り返しで実行する一連の文の集まり  
- ブロックの書き方  
ブロックとは、複数の文をひとまとまりとして扱うためのもので、2のルールがある  
・ルール1　波カッコの省略  
　ブロックは波カッコで囲まれた部分を指しているが、内容が1文しかなければ、波カッコを省略できる(ミス防止のため、省略することは推奨されていない)  
・ルール2　ブロック内で宣言した変数の寿命  
　ブロック内で新たに変数を宣言することもできるが、ブロックで宣言した変数は、そのブロックが終わると同時に消滅する  
　変数が利用可能な場所の範囲をスコープという  
- 条件式の書き方  
　条件式とは、if分やwhile文で利用される式の1つで、「処理を分岐する条件」や「繰り返しを続ける」を表現するためのもの、条件式では関係演算子を使う  
・関係演算子  
演算子　意味  
==　　 左辺等辺が等しい  
!=　　　左辺等辺が異なる  
＞　　　左辺が右辺より大きい  
＜　　　右辺が左辺より小さい  
＞=　　左辺が右辺より大きいか等しい  
＜=　　左辺が右辺より小さいか等しい  
・文字列の比較  
　Javaもルール上、文字列は==では正しく比較できないので、次のように記述する  
　文字列型の変数.equals(比較相手の文字列)  
・論理演算子  
　「年齢が18歳以上、かつ5月生まれ」のように2つ以上の条件を組み合わせた条件式の時に使う  
演算子　　意味  
&&　　　かつ(両方の条件が満たされた場合にtrue)  
||　　　　または(どちらか片方の条件さえ満たされればtrue)  
!　　　　 もし~でないなら(直後の条件式や値のtrueとfalseを反転させる)  
- 分岐処理のバリエーション  
・3種類のif構文  
　①if-else構文  
　②ifのみの構文(falseの時は何もしない時)  
　③if-else if-else構文(falseの時にさらに別の条件で分岐したい時　この時最後のelseブロックの中身が空ならelseごと省略できる)  
・switch文による分岐  
　switch文にできる条件  
　①すべての条件式が==で左辺と右辺が一致するかを比較する式になっており、それ以外の>、<、!=などが使われていない  
　②比較する対象が整数(byte型、short型、int型のいずれか)、文字列(String型)または文字(char型)であり、少数や真偽値ではない  

　　　switch文の注意点  
　　　①switch文の直後には、条件式ではなく、変数名を書く  
　　　②case(「~の場合は」)の横には値を書き、その後ろには -> {条件内容}を記述する  
　　　③defalt -> {条件処理}の部分は、条件に合致しないときの処理が不要な場合は省略可能である  
　　　④caseやdefaltのブロックを{}で囲まず、break;で終わらせることもできるが、break；を書き忘れるとコンパイルエラーにはならず、すぐ下のcase文も続けて実行されてしまう  

- 繰り返し構文のバリエーション  
・2種類のwhile文  
　①ブロックを実行する前に条件式を評価する(while構文)  
　②ブロックを実行した後に条件式を評価する(do-while構文)  
　無条件に処理を行って、その後、条件によっては繰り返しをしたい時に使用  
　do {  
　　ブロック  
  　} while(条件式);  
  ＊while構文とdo-while構文の違いは、while文は条件式の判定がfalseだった場合は一度もブロックを実行しないが、do-while構文はブロックを実行した後に条件判定を行うため、最低でも一度はブロックを実行する  
・for文による繰り返し  
　「x回だけ繰り返す」のように繰り返しの回数が決まっている場合は、for文を使うとよりシンプルなコードになる  
　for (int i = 0; i < 10; i++) {・・・}  
　＊変数はiでなくてもいいが、3つとも同じものを使う、10のところに繰り返す回数を書けばその分繰り返す  
・for文の各部の意味  
　forに続くカッコの中は、セミコロンによって区切られた3つの部分(左から①初期化処理、②繰り返し条件、③繰り返し時処理)で構成されている  
　①初期化処理  
　forによる繰り返しの前に、最初に1回だけ実行される文。「何周目のループかを記録しておく変数」を定義する、この変数をループ変数という  
　②繰り返し条件  
　ブロックの内容を実行する前に評価される、ループを継続するか否かを判定する条件式。評価結果がtrueの間は、ブロックが繰り返し実行される  
　＊for文はwhile文と同じ前置判定の繰り返し構文なので、後置判定はできない  
　③繰り返し時処理  
　for文内のブロックを最後まで処理して、ブロックを閉じる波カッコまで到達した直後に自動的に実行される文。通常は、i++のようにループ変数の値を1だけ増やす分を書く  
・ループ変数  
　①ループ変数の名前は、iに限らず自由に決めることができるが、for文より前に宣言されている変数名は使えない  
　②ループ変数も通常の変数なので、ブロック内での計算や表示に使える  
　③for文を抜けるとループ変数は消失するので、ブロック外では利用不可能  
・複雑なfor文  
　for文の「①初期化処理」、「②繰り返し条件」、「③繰り返し時処理」の3つを工夫すると、より高度な繰り返しを実現できる  
　例)  
　①ループ変数を1からスタートする  
　for (int i = 1; i < 10; i++) {・・・}  
　②ループ変数を2ずつ増やす  
　for (int i = 0; i < 10; i += 2) {・・・}    
　③ループ変数を10から1ずつ1まで減らしていく  
　for (int i = 10; i > 0; i--) {・・・}  
　④ループ変数を初期化しない  
　for (; i < 10; i++) {・・・}  
　⑤繰り返し時の処理を行わない  
　for (int i = 0; i < 10;) {・・・}  

- 制御構文の応用  
・制御構造のネスト  
　分岐や繰り返しの制御構造は、その中に別の制御構造を含むことができる。このような多重構造を入れ子やネストという  
・繰り返しの中断  
　for文やwhile文を用いた繰り返しの中で、中断したい場合は、break文かcontinue文で中断ができる  
　①break文は、breakを囲んでいる最も内側の繰り返しブロックが即座に中断される。繰り返し自体を中断したい場合に使用  
　②continue文は、今の周回を中断して、同じ繰り返しの次の周回に進みたい場合に使用  
・無限ループ  
　無限ループは強制停止されない限り永久に繰り返しを続ける制御構造のこと  
　無限ループの作成方法  
　① while (true) {処理}   
　② for (;;) {処理}  

## 配列  
- 配列のメリット    
・配列  
　配列とは1つの種類の複数データを並び順で格納するデータ構造。配列の中には、変数のような箱が連続して並んでいて、その1つひとつを要素という。要素は通常の変数のように型を持ち、1つのデータを格納できる。配列内の各要素には0から始まる番号が付いていて、これを添え字という  
- 配列の書き方  
・配列の作成  
  ・配列変数の作成(宣言)  
　　要素の型[] 配列変数名  
　　例)　int[] scores;  
  　　　　 scores = new int[5];  
  ・並列変数の宣言と要素の作成と代入を同時に行う方法  
　　int[] scores = new int[5];  
  ・配列の要素数の取得  
　　配列変数名.length  
・配列の利用  
　配列のどの要素に値を出し入れするかを指定するためには、scores[1] = 10;のように添え字を用いる(配列scoresの先頭から2つ目の要素に10を代入をしている)  
・配列の初期化  
　変数の値を取り出す前には、必ず値を代入して初期化しなければならないが、配列の要素は自動的に初期化される  
・省略記法  
　・配列作成と初期化の省略記法  
　① 要素の型[] 配列変数名 =  
　　　　new 要素の型[] {値1, 値2, 値3, ・・・};   
　② 要素の型[] 配列変数名 =  {値1, 値2, 値3, ・・・};  
　例)  
　int[] scores1 = new int[] {20, 30, 40, 50, 80};  
　int[] scores2 = {20, 30, 40, 50, 80};  
- 配列のデータをまとめて扱う  
・配列とfor文  
　配列の添え字には0や2といった固定の値(リテラル)だけでなく、変数を指定することもできる  
  配列活用の定石  
　パターン1　ループによる全要素の利用  
　パターン2　ループによる集計  
　パターン3　添え字に対応した情報の利用  
・パターン1　ループによる全要素の利用  
　配列の最初から最後までの要素を順にアクセスするパターン  
　添え字にはループ変数を指定しているため、ループのたびに0→1→2→3→4と変化し、最初から最後までの要素を順にアクセスする  
　要素の数が変わったとしても、for文の記述には影響がない  
　forループで配列を回す  
　for(int i = 0; i < 配列変数名.length; i++) {  
　　配列変数名[i]を使った処理  
　}  
・パターン2　ループによる集計  
　ループに入る前に、集計結果を入れるための変数sumを0で初期化し、for文で葉入れるを回して要素を1つずつ足していく。ループが終了した段階で、変数sumには配列の全要素の値が合算されている  
　このパターンは合計や平均を求める集計の他に、ある条件と一致する要素の数を数えるカウント集計という処理にも使われる  
・パターン3　添え字に対応した情報の利用  
  配列の中に配列を指定することで、配列で指定された回数処理が行われる  
・拡張for文  
  Javaには、配列の要素を1つずつ取り出すループを書くための特殊なfor文(拡張for文)が準備されている  
  拡張for文では、ループが1周するたびに、「任意の変数名」に指定した変数に配列の要素の内容が格納されるため、ループ変数や配列の添え字を記述する必要がなくなる  
　拡張for文で配列を回す  
　for(要素の型 任意の変数名 : 配列変数名) {  
　　:  
　}  
- 配列の後片付け  
・ガベージコレクション  
　配列変数の寿命は変数の寿命と同じで、宣言したブロックが終了するまでだが、newで確保された要素はブロックが終了しても寿命は向かえない。その結果、配列はどの配列変数からも参照されない状態でメモリに残ってしまう。しかし、Javaにはガベージコレクションというしくみが常に動いていて、実行中のプログラムが生み出したメモリ上のゴミ(どの変数からも参照されなくなったメモリ領域)を自動的に探し出して片づけてくれる。  
・null  
　nullとは「何もない」という状態を表す値、参照型の変数に代入することができる。nullが代入されると、参照型の変数はどこにも参照しない状態になる。この参照しない状態にすることを「参照を切る」ともいう。どの変数からも指されないので、ガベージコレクションの対象になる  
・NullPointerException  
　nullを代入したコードはどこも参照していないがコンパイルは成功する。しかし、実行するとエラーとなりNullPointerExceptionと表示される  
　この例外は、nullが格納されている配列変数を利用しようとしたときに発生する  
- 多次元の配列  
・多次元配列とは
  ここまで学習してきた配列を1次元配列といい、1次元配列に縦の並びを加えると2次元配列になる  
　2次元配列は要素が縦横に並んだ表のようなもので、データを表のような形で扱いたい時に使用すると便利  
　2次元以上の配列を多次元配列という。業務システム開発では使う機会は少ないが、科学技術計算などではよく利用される  
　・2次元配列の宣言  
　　要素の型[][] 配列変数名 = new 要素の型 [行数] [列数];
　・2次元配列の要素の利用  
　　配列変数名[行の添え字][列の添え字]  

## メソッド  
- メソッドとは  
・メソッドを利用するメリット  
　・プログラムの見通しがよくなり、全体を把握しやすくなる  
　・機能単位に記述するため、修正範囲を限定できる  
　・同じ処理を1つのメソッドにまとめることで、作業効率が上がる  
・メソッドの定義  
　メソッドを作成することメソッドの定義という  
　メソッドの定義  
  public static void メソッド名() {  
  　メソッドが呼び出されたときの処理  
　}  
・メソッドの呼び出し  
　メソッドを使用することをメソッドの呼び出すという  
　メソッドの呼び出し  
　メソッド名()  
　以下のコードの場合、mainメソッドが開始され、mainメソッドの中に書かれたhello();でhelloメソッドを呼び出す  
　public class Main {  
   public static void main(String[] args) {  
     System.out.println("メソッドを呼び出します");  
     hello();  
     System.out.println("メソッドの呼び出しが終わりました");  
   }  
   public static void hello() {  
     System.out.println("湊さん、こんにちは");  
   }  
 }  
・mainメソッド以外からのメソッドの呼び出し  
　メソッドは、mainメソッド以外のメソッドからも呼び出すことができる。以下のコードの場合の処理の流れは、main()→methodA()→methodB()の順に実行される  
　public class Main {  
   public static void methodA() {  
     System.out.println("methodA");  
     methodB();  
   }  
   public static void methodB() {  
     System.out.println("methodB");  
   }  
   public static void main(String[] args) {  
     methodA();  
   }  
 }  
・メソッドにまつわる2つの立場  
　メソッドにまつわる2つの立場  
　立場1 メソッドを定義する立場  
　立場2 メソッドを呼び出す立場  
　メソッドを定義する人は、メソッドを呼び出す人のことを考えてメソッドを作成する必要がある。メソッド名をaaa()やkeisan()のような名前ではなく、hello()やsaveToFile()のような名前が望ましい  
- 引数の利用  
・引数とは  
　メソッドを呼び出す際に、呼び出し元から値を渡すことができる。このときに渡される値のことを引数という。呼び出されたメソッド側では、渡された値を受け取って処理に利用でき、引数には数値や文字列などを指定でき、その値や型、渡す引数の数は開発者が自由に決めることができる  
・1つの引数を渡す  
　メソッドを呼び出す際、()の中に値を入れておくと、その値が引数として呼び出される側のメソッドに渡される  
・複数の引数を渡す  
　引数として渡す値が複数ある場合、値をカンマで区切って使用する。また、値を受け取るメソッド側でも、受け取る変数をカンマで区切って宣言する。このとき、引数として渡される値と、メソッド側で宣言する変数の型と順番を合わせる必要がある。引数と変数の型が合致しない場合にはコンパイルエラーが発生する  
　public class Main {  
   public static void main(String[] args) {  
     add(100, 20);  
     add(200, 50);  
   }  
   // 複数の値を受け取るaddメソッド  
   public static void add(int x, int y) {  
     int ans = x + y;  
     System.out.println(x + "+" + y + "=" + ans);  
   }  
　}  
　・引数を利用したメソッドの定義  
　　public static void メソッド名(引数リスト) {  
     メソッドの処理  
　　}  
　・引数を利用したメソッドの呼び出し  
　　メソッド名(引数リスト)  
　 *値には、変数名を指定することもでき、複数の引数を渡すときはカンマで区切って指定する  
・仮引数と実引数  
　引数の内、メソッドに渡す値を実引数、メソッドが受け取る変数を仮引数と呼ぶ  
・変数のスコープとローカル変数  
　変数のスコープとは、その変数が利用できる有効範囲のこと  
　ブロック内で宣言された変数のスコープは、そのブロック内に限定される。このような変数の性質をローカル変数の独立性という  
　メソッド内で宣言した変数をローカル変数と呼び、仮引数もその一種である  
　ローカル変数は、その変数が属するメソッド内だけで有効な存在であって、別のメソッドに属する同盟のローカル変数とは別物  
- 戻り値の利用  
・戻り値とは  
　呼び出されたメソッドから、呼び出し元のメソッドへ値を返すことを値を戻す(または値を返す)という。また、呼び出される値のことを戻り値(または「返り値」)という  
　・戻り値を利用したメソッドの定義  
　　public static 戻り値の型 メソッド名(引数リスト) {  
　　　メソッドの処理  
　　　return 戻り値;  
　　}  
　メソッドブロックの最終行に登場したのはreturn文という。この文は、「return]の後ろに書かれた値を呼び出し元に戻す約w利を担っている。変数に入っている値を戻すには、return変数名;のように変数名を指定する。return 100;やreturn "hello";のようにリテラルを指定することもできる  
　メソッド名の左側は、「void」ではなく「戻り値の型」となっている。ここには、returnによって戻される値と同じ型を指定する。整数を戻す場合は「int」、文字列型を戻す場合は「String」、変数に入っている値を戻す場合は、その変数の方を書く。何も戻さない場合は「void」を指定する(voidは「何もない」という意味)  
・戻り値を受け取る  
　戻り値は引数と同様に、変数を用意して受け取る必要がある。受け取るには、メソッドの呼び出し元で次の構文を使用する  
　・戻り値を利用したメソッド呼び出し  
　　型 変数名 = メソッド名(引数リスト);  
　文に代入演算子「=」がある場合、常に右辺から先に評価されるので、まずはメソッドの呼び出しが実行される。呼び出されたメソッドがreturn文によって値を戻す場合、「メソッド名(引数リスト)」の部分は評価されて戻ってきた値に置き換わる。それによって、型 変数名 = メソッドの戻り値;という状態になり、戻り値が変数に代入される  
　・戻り値の例  
　　public class Main {  
  　　public static int add(int x, int y) {  
    　　int ans = x + y;  
    　　return ans;  
  　　}  
  　　public static void main(String[] args) {  
    　　int ans = add(100, 10);  
    　　System.out.println("100 + 10 = " + ans);  
  　　}  
　　}  
　　*よくある書き方の間違い  
　　1. add(100,10) = int ans;  
　　addを呼び出そうとして add(100,10) と書き、ansに代入しようと = int ans; と書いてしまうパターン。構文として間違っているためコンパイルエラーになる  
　　2. add(100,10);  
　　addを呼び出そうとして int ans = の部分を書き忘れてしまう。add()は正しく実行されて結果の110が戻ってきているが、呼び出し元で受け取っていないため、mainメソッド内で戻り値を利用できない  
・戻り値をそのまま使う  
　メソッドの戻り値を変数で受けずに、そのまま使うこともできる  
　public class Main {  
  　public static int add(int x, int y) {  
    　int ans = x + y;  
    　return ans;  
  　}  
  　public static void main(String[] args) {  
    　System.out.println(add(add(10, 20), add(30, 40)));  
  　}  
　}  
　addメソッドの呼び出しが3つある。add(10, 20)とadd(30, 40)が実行され、それぞれの結果である「30」と「70」が戻り値として呼び出し元に返される。これによりカッコの外側のaddメソッドは add(30,　70)という状態になる。そして、「30」と「70」の引数を持ってaddメソッドが再び呼び出され「100」が addメソッドより戻される。最終的に System.out.println(100); という状態になり、画面には「100」が表示される  
・return文の注意点  
　return文は値を戻すだけでなく、メソッドの終了も行う。そのため、return文の後に処理を書いても実行されない  
- オーバーロードの利用  
・類似する複数のメソッドを定義する  
　プログラムが大きくなてくると、「似たような処理を行うメソッドを複数作る」必要に迫られることがある。しかし、処理内容が似ているからといって、メソッドに同じ名前は付けられない。同じ名前のメソッドが複数あると、JVMはどれを実行してよいか判断できないのでコンパイルエラーになる  
　しかし、例外的に同じ名前のメソッドを複数定義する方法がある。同じ名前のメソッドを定義することをオーバーロード(overload)または多重定義という  
　public class Main {  
  　// 1つ目のaddメソッド  
  　public static int add(int x, int y) {  
    　return x + y;  
  　}  
  　// 2つ目のaddメソッド  
  　public static double add(double x, double y) {  
    　return x + y;  
  　}  
  　// 3つ目のaddメソッド  
  　public static String add(String x, String y) {  
    　return x + y;  
  　}  
  　public static void main(String[] args) {  
    　System.out.println(add(10, 20));  
                       　/* 1つ目のaddメソッドが呼び出される */  
    　System.out.println(add(3.5, 2.7));  
                       　/* 2つ目のaddメソッドが呼び出される */  
   　 System.out.println(add("Hello", "World"));  
  　}                    /* 3つ目のaddメソッドが呼び出される */  
　}  
　定義されている3つのaddメソッドの型を見ると、1つ目は「int, int」、2つ目は「double, double」、3つ目は「String, String」となっている  
　仮引数が異なれば同じ名前のメソッドを複数定義することが許される。同じ名前のメソッドが複数あったとしても、仮引数の型が異なれば、JVMが呼び出し元の引数(実引数)を見て、その引数の方に一致するメソッドを呼び出してくれる(仮引数の型だけでなく、個数が違う場合もオーバーロードできる)  
- 引数や戻り値に配列を用いる  
・引数に配列を用いる  
　メソッドの引数にはint型やString型などの変数だけでなく、配列も使うことができる  
・値渡しと参照渡し  
　引数として通常の変数を指定した場合、メソッドに渡されるのは変数ではなく、変数に入っている値が渡される(メソッドを呼び出した時点で変数に代入されている値が、メソッドの仮引数にコピーされる)。この値そのものが渡される呼び出しを値わたし(call by balue)という  
　・基本型の変数をメソッド呼び出しで渡すこと  
　　・呼び出し元の変数の内容が、呼び出し先の引数にコピーされる  
　　・呼び出し先で引数の内容を書き換えても、呼び出し元の変数は変化しない  
　・メソッドの呼び出しで基本型変数ではなく配列を渡した場合  
　　メソッド呼び出しの際にコピーされるのは、配列の内容ではなく配列の先頭要素のアドレスとなる  
　　例)  
　　int[] array = {1,2,3};  
　　printArray(array);  
　　  
　　printArrayメソッド内でarray[0]に100を代入したら、この要素が100に書き換わる。printArrayメソッドが終了した後、mainメソッド内でarray[0]を取り出したら100を取り出すことになる  
　　引数としてアドレスを渡すことを参照渡し(call by reference)というが、参照渡しを行うと呼び出し先で加えた変更が呼び出し元にも影響する  
　・配列メソッド呼び出しで渡すこと  
　　・呼び出し元の配列のアドレスが、呼び出し先の引数にコピーされる  
　　・呼び出し先で配列の実態を書き替えると、呼び出し元にも影響する  
・戻り値に配列を用いる  
　引数と同様に、戻り値に配列を使用することができる  
　return 戻り値;によって配列の先頭要素のアドレスがmainメソッドに戻される。mainメソッドでは、それを自身で宣言した配列変数に代入して、作成された配列を参照できるようになる  
・コマンドライン引数  
　mainメソッドは文字列配列を引数として受け取るように定義されている  
　Javaのプログラムを起動する際、さまざまな「追加情報」を指定して起動することができる。このプログラム起動時の追加情報をコマンドライン引数という  
　・コマンドライン引数を利用したJavaプログラムの起動  
　　Java プログラム名 引数リスト  
　　*引数リストは()で囲まずに、半角スペースで区切って入力する  
　・コマンドライン引数  
　　プログラム起動時に指定したコマンドライン引数が、JVMによって配列に変換されｍmainメソッド起動時に渡される  

## 複数クラスを用いた開発  
・1つのソースファイルによる開発  
　1つのソースファイルの中に含まれるメソッドの数が増えると、ソースコード全体を把握するのは難しくなり、開発しにくくなってしまう  
　Javaでは、1つのソースファイルにはすべてのメソッドを書くのではなく、複数のソースファイルに分割して記述できるしくみがある。複数のソースファイルに分けて開発するのは、複数のクラスに分けて開発すると捉えることもできる  
　たくさんのメソッドを複数のクラスに分けて記述すると、整理されて分かりやすくなるだけでなく、ファイルごとに開発を分担し、それぞれが並行して開発を進められる(分業しやすい)というメリットもある  
・計算機プログラムを分割しよう  
　以下のコードを2つのクラスに分割する(Calc.java)  
　public class Calc {  
  　public static void main(String[] args) {  
    　int a = 10; int b = 2;  
    　int total = tasu(a, b);  
    　int delta = hiku(a, b);  
    　System.out.println("足すと" + total + "、引くと" + delta);  
  　}  
  　public static int tasu(int a, int b) {  
    　return (a + b);  
  　}  
  　public static int hiku(int a, int b) {  
    　return (a - b);  
  　}  
　}  
　tasu()やhiku()の2つは数学的な計算処理をするメソッドで、main()はtasu()やhiku()を呼び出して画面に表示する役割を持つ、全体の流れをつかさどるメソッド。main()とそれ以外のメソッドを2つのクラスに分けて整理する  
　①計算処理メソッドを記述するためのソースファイルを作成する  
　　計算ロジックのメソッドを入れるソースファイルを作成する(CAlcLogic.java)  
　②tasu()とhiku()を移動する  
　　Calc.javaの中にあるtasu()とhiku()をCalcLogic.javaに移動する  
　　public class CalcLogic {  
  　　public static int tasu(int a, int b) {  
    　　return (a + b);  
  　　}  
  　　public static int hiku(int a, int b) {  
    　　return (a - b);  
  　　}  
　　}  
　③メインメソッド内の呼び出しを修正する  
　　メインメソッド内でtasu()やhiku()を呼び出そうとしているが、移動させたので呼び出せない。「CalcLogicのtasu()」「calcLogicのhiku()」のように明示的に所属を示す必要がある  
　　int total = CalcLogic.tasu(a, b);  
　　int delta = CalcLogic.hiku(a, b);  
　修正したCalc.java  
　public class Calc {  
  　public static void main(String[] args) {  
    　int a = 10; int b = 2;  
    　int total = CalcLogic.tasu(a, b);  
    　int delta = CalcLogic.hiku(a, b);  
    　System.out.println("足すと" + total + "、引くと" + delta);  
  　}  
　}  
- 複数クラスで構成されるプログラム  
・複数クラスのコンパイル  
　分割したプログラムはそれぞれをコンパイルする必要がある。複数のソースファイルをjavacコマンドでコンパイルするときは以下のように記述する(前節のファイルで例える)  
　javac Calc.java CalcLogic.java  
　コンパイルが終了すると、それぞれのソースファイルに対応したクラスファイルが作成される  
・Javaプログラムの完成品  
　通常のアプリケーションはファイルは1つだが、Javaで開発されたプログラムは「複数のクラスファイルの集まり」であることが多い(起動はダブルクリックではなく、javaコマンドで起動させる)。そのため、Javaプログラムを誰かに渡す、あるいは納品する場合は、複数のクラスファイルが入っているフォルダををまるごと「1つの完成品」として渡す  
・プログラムの実行方法  
　クラスフォルダが入ったファイルをまるごと受け取った場合は、クラス名を指定して実行する必要がある  
　java クラス名  
　JVMは起動時に指定されたクラスファイルの中にあるmainメソッドを呼び出してプログラムの実行を開始する。よって、Javaプログラムを実行する人は「渡された複数のクラスファイルのうち、mainメソッドが含まれているクラスの名前」を指定する必要がある。複数の完成クラスファイルを渡す場合は、「mainメソッドが含まれるクラス名」を伝える必要がある  
- パッケージを利用する  
・クラスが増えすぎた時  
　クラスの数が数百個になると管理が大変になる。Javaには、各クラスをパッケージ(packeage)と呼ばれるグループに所属させて、分類・管理できるしくみが準備されている  
　*main()の行数が増えたら複数メソッドに分割→メソッド数が増えたら複数クラスに分割→クラス数が増えたら複数パッケージに分割  
　・クラスをパッケージに所属させる  
　　packeage 所属させたいパッケージ名;
　　*packeage文はソースコードの先頭に記述する  
　前節の計算機プログラムの場合、packeage calcapp.main;やpackeage calcapp.logics;になる  
　*パッケージの中にパッケージを入れることは出来ず、パッケージに親子関係はない。また、どのパッケージにも所属していない状態を「無名パッケージに属している」または「デフォルトパッケージに属している」と表現する場合もある    
・パッケージを含むクラス名を指定する  
　パッケージはそれぞれ独立しているので、パッケージを指定しないでコンパイルをすると自分と同じパッケージに所属するクラスを呼び出そうとすると構文エラーが発生する  
　別のパッケージに所属しているクラスを利用するには、所属しているパッケージ名を添えたクラス名を指定する必要がある。あるクラスから別パッケージのクラスを利用する場合、「パッケージ名を頭に付けた完全なクラス名」を使う必要がある。この完全なクラス名のことを、完全限定クラス名や完全修飾クラス名(full qualifited class name)、または略してFQCNという  
  ・完全限定クラス名(FQCN)  
　　パッケージ名.クラス名  
・完全限定クラス名の入力を省略する  
　プログラムが大きくなったら、calcapp.calcapp.logics.CalcLogicのように長い完全限定クラス名(FQCN)を何度もコードの随所に入力する必要がでてくる。このような場合は、import文を使うことによって、FQCN入力の手間を軽減できる  
　・記述例  
　package calcapp.main;  
　import calcapp.logics.CalcLogic;  
  
　public class Calc {  
　　public static void main(String[] args) {  
　　　int a = 10; int b = 2;  
　　　int total = CalcLogic.tasu(a, b);  
　　　int delta = calcapp.logics.CalcLogic.hiku(a, b);  
　　　System.out.println("足すと" + total + "、引くと" + delta);  
　　}  
　}  
  
　このimport文では「このソースコードでCalcLogicという表記があったら、それはcalcapp.logics.CalcLogicのことだと解釈しなさい」という指示になる。頻繁に利用するクラスはimport文を使ってインポートしておくと、完全限定クラス名を毎回指定する必要がなくなる  
　・calcapp.logicsパッケージに所属するすべてのクラスをインポートしたい場合  
　　package calcapp.main;  
　　import calcapp.logics.*;  
  
　　public class Calc {  
  　　public static void main(String[] args) {  
    　　int a = 10; int b = 2;  
    　　int total = CalcLogic.tasu(a, b);  
    　　int delta = calcapp.logics.CalcLogic.hiku(a, b);  
    　　System.out.println("足すと" + total + "、引くと" + delta);  
  　　}  
　　}  
　*import calcapp.logics.*;と記述すると、calcapp.mainとcalcapp.logicsに所属するすべてのクラスを一度にインポートできない(「calcapp.main」と「calcapp.logics」、「calcapp」はまったく異なるパッケージであり、親子関係にないからである)。この指定では、calcappパッケージに所属するすべてのクラスがインポートされる  
　・calcapp.mainとcalcapp.logicsに所属するすべてのクラスをインポートしたい場合  
　　import calcapp.main.*;  
　　import calcapp.logics.*;  

- パッケージに属したクラスの実行方法  
・実行クラス名の正しい指定  
　パッケージを利用していない時は、「java クラス名」で実行できたが、パッケージを利用している時はコンパイルは出来るがエラーとなる(java クラス名ではデフォルトパッケージを実行しようとしているため)  
　・javaコマンドの正確な構文  
　　java 起動したいクラスの完全限定クラス名(FQCN)  
・クラス名だけでクラスファイルを探し出すためのしくみ  
　・クラスローダー  
　　JVMが内部に持っている機構のこと。クラスローダーは、完全限定名を指定されたら、その名前を持つクラスのクラスファイルをPC内から検索し、JVMに読み込んで利用利用可能にするという役割を担っている。JVMは使いたいクラス名を指定しているだけであって、クラスファイルが置いてあるフォルダの場所を指定していない。クラスローダーはクラスパス(classpath)と呼ばれるヒント情報を使って、目的のクラスファイルを探し出す。クラスパスとは、クラスローダーがクラスファイルを探す際に、見にいくべきフォルダの場所で、あらかじめ1つ以上のクラスパスを指定しておく  
・クラスパスの指定方法  
　クラスパスを指定する方法は以下の3つ  
　①起動時にjavaコマンドで指定する  
　　javaコマンドでJVMを起動する際に、-cpオプションまたは-classpathオプションで指定する方法  
　　java -cp c:¥work Calc  
　②検索場所をOSに登録しておく  
　　OSの「環境変数」という設定にクラスパスを登録しておくことができる。javaコマンドは、この環境変数を自動的に読み込んでクラスファイルの検索に利用する   
　③特に指定しない  
　　環境変数に指定がなく、-cpオプションの指定もない場合、通常はjavaコマンドが実行されたフォルダがクラスパスとなる。例)c:¥workでjavaコマンドを実行したら、c:¥workがクラスパスに設定される  
・クラスパスで指定できる対象  
　クラスパスとして指定することができるものは、以下の3つから選べる  
　①フォルダの場所  
　　クラスファイルが置かれているフォルダの場所(絶対パス)。例)「c:¥work」と指定すると、、workフォルダ内のクラスファイルが検索対象となる  
　②クラスファイルが入ったJARファイルやZIPファイル  
　　クラスファイルが入っているJARファイルやZIPファイルがあれば、そのファイルの場所(絶対パス)をクラスパスとして指定できる。クラスローダーは指定されたファイルの中を検索し、もしクラスファイルが見つかれば読みこむ。例)Calc.classが入ったcalcapp.jarというファイルがc:¥work¥jarsにある場合、「c:¥work¥jars¥calcapp.jar」をクラスパスに指定すると、Calc.classを読みこむことができる  
　③複数のフォルダ、JAR/ZIPファイル、それらの組み合わせ  
　　複数のフォルダやJARファイル、ZIPファイルをデリミタ文字で区切ってクラスパスに指定できる。デリミタ文字は、Windowsの場合はセミコロン(;)、macOSやLinuxの場合はコロン(:)。クラスローダーは、指定された場所を前から順に探す  
　・Windowsの例  
　　c:¥work;c:¥work¥jars¥calcapp.jar  
　・LinuxやmacOSの場合  
　　/var/javadev:/var/javadev/jars/calcapp.jar  
・クラスファイルの正しい配置  
　クラスローダーはクラスパスで指定されたフォルダを足しように、探しているファイルを調べる。このとき、次のようなルールでパッケージに属しているクラスファイルを探す  
　・パッケージに対するクラスローダーの動作  
　　パッケージx.y.zに属するクラスCが対象なら、「クラスパスで指定されたフォルダ¥x¥y¥z¥C.class」を探そうとする  
　パッケージに属したクラスファイルをクラスローダーに読み込んでもらうには、現在のクラスパスを基準として、パッケージ階層に対応したフォルダを作り、その中に必要なクラスファイルを配置しておく必要がある  
　例)c:¥workをクラスパスとする場合、コンパイルによって生成されたCalc.classとCalcLogic.classは次のようなフォルダを作成し、その中に配置しなければならない  
　　　Calc.class　　　　　→　　　c:¥work¥calcapp¥mainフォルダ  
　　　calcLogic.class　　→　　　c:¥work¥calcapp¥logicsフォルダ  
  
　・クラスファイルを適切なフォルダに置いた状態で実行した場合の読み込みの流れ  
　①JVMは起動させるクラス名(calcapp.main.Calc)を受け取る  
　②JVMはクラスローダーにcalcapp.main.Calcの読み込みを指示する  
　③クラスローダーはクラスパスを確認する  
　④クラスローダーは、クラスパスを基準として「calcapp」→「main」とフォルダを降りていき(c:¥work¥calcapp¥mainの中)、そこにCalc.classというファイルを発見する  
　⑤クラスローダーは発見したCalc.classを読み込む  
　⑥JVMは読み込んだCalcクラスのmainメソッドを実行する  
- 名前空間  
・パッケージを使うもう1つのメリット  
　パッケージには、クラスをグループ化して整理し、プログラムを分かりやすくする目的の他に自分が作るクラスに対して、開発者が自由に名前を付けられるようにする役割がある  
　大規模な開発現場では、複数の開発者が分担して各自が受け持ったクラスを開発する。このとき、それぞれの開発者が偶然「同じクラス名を使ってしまう」可能性が出てくる。この内容が異なる別々のクラスで同じ名前を取り合うことを「名前の衝突」という。異なるクラスで同じクラス名を使うと区別が付かなくなってしまうため、Javaではクラス名の衝突は原則として許されない。使うことができる名前の総量(名前空間)は限られていて、新しくクラスを作ると、そのクラス名は使えなくなり、使えるクラス名は減っていく  
　パッケージが異なれば同じクラス名を使うことができる。クラス名が同一でも、パッケージ名が異なれば完全限定クラス名(FQCN)が異なるので両者を区別できる。パッケージの利用によって、それぞれのパッケージの中ではクラス名を自由に決めることができる  
・パッケージ名の衝突を避ける方法  
　クラス名と同様にパッケージ名も同じ名前だと区別が付かなくなる。自社の開発プロジェクトなら、誰がどのようなパッケージ名を使うかを事前に決めておけば衝突は回避できる。しかし、他社のパッケージを利用する場合、パッケージ名が衝突しないように事前にコントロールするのは困難である  
　解決策して、Javaでは自分(自社)が保有するインターネットドメインを前後逆順にしたものから始まるパッケージ名の使用を推奨している。例)foo.example.comというインターネットドメインを取得している企業であれば、com.example.fooで始まるパッケージ名を使う  
  
# スッキリ納得 オブジェクト指向  
  
## オブジェクト指向をはじめよう  
- オブジェクト指向ことはじめ  
・オブジェクト指向プログラミングをマスターしよう  
　オブジェクト指向プログラミング(Object Oriented Programing = OPP)という考え方に従ってプログラムを書くと、大規模なプログラムもラムに開発することができるようになる
- オブジェクト指向の定義と効果
・オブジェクト指向の定義
　オブジェクト指向とは、ソフトウェアを開発するときに用いる部品化の考え方のこと  
・オブジェクト指向のメリット  
　オブジェクト指向の根底にある目的は、人間が内容を把握しやすいプログラム開発を実現するというものである。この考え方を利用した「賢い部品化」を行うと、把握しやすさが向上するほかにも次のようなメリットが生まれる  
　　・プログラムの変更が容易になる(柔軟性・保守性の向上)  
　　・プログラムの一部を簡単に利用できる(再利用性の向上)  
　しかし、javaを学び始めた段階では、上記のメリットは実感しにくい。現段階で抱くべきメリットは「ラクして、楽しく、良いものを作れる」となる  
- オブジェクト指向の全体像と本質  
・オブジェクト指向と現実世界  
　私たちが開発するプログラムやシステムの多くは、現実正解における何らかの活動を自動化するためのもの  
　　例)ATM = コンピュータが無かった頃には人間が行っていた作業(依頼の受付、残高の検査、引き出し、記帳、受け渡し)を機械に肩代わりさせている  
　このようにプログラムやシステムは、現実世界のある活動を人間に代わって機械にやらせるために作られるものであって、現実世界と無関係に単独で存在しているものは、ほとんどない  
・手続きプログラミングとの違い  
　手続きプログラミングとは、開発者が頭を捻り、コンピュータがどのように動けばいいかという手順を考え、プログラムの先頭から順番に命令として記述していく方法  
　オブジェクト指向で開発を行う場合、いきなりコードを書き始めることはせず、実現しようとする部分の「現実世界」を観察し、設計図を作成する。この設計図は、ITの知識がない人に見せても理解でき、設計図の中の登場人物や物1つひとつを部品と捉え、それを「クラス」というJavaにおける部品で記述していく  
・開発時に作るクラス、実行時に動くオブジェクト  
　開発時に作られたクラスは、プログラムとして実行されると、それぞれ仮想的な登場人物のオブジェクトとしてJVMの中にその存在が生み出される  
　ATMのプログラムの場合は、「仮想的な口座」「仮想的な受付」「仮想的な印刷担当」などが、コンピュータ(JVM)という「電子的な仮想世界」の中に作られ、現実世界をそっくりまねたJava仮想世界とでもいえるような世界を形成する  
・オブジェクト指向における開発者の役割  
　オブジェクト指向プログラミングにおいて、開発者は神様のような存在といえる。仮想世界にどんな登場人物や物を生み出し、それらをどのように連携させるかを決め、それぞれの部品を作っていく立場であるからである  
　手続き型のプログラミングのように「コンピュータが実行すべき手順を1行ずつ定める」のではなく、「オブジェクトをどう作るか、どのように連携させるか」を第一に意識しながら開発していく。このことが「オブジェクト指向プログラミング」という名前の由来になっている  
・オブジェクト指向の本質  
　問「なぜオブジェクト指向の考え方を使うと、大規模で複雑なプログラムも把握しやすくなり、その結果、ラクして楽しく良いものを作れるのか？」  
　答「私たち人間が慣れ親しみ、よく把握している現実世界をマネして作られたプログラムもまた、私たち人間にとって把握しやすいものだから」  
　さらに、オブジェクト指向には以下のメリットもある  
　　・プログラム開発時に、「手続きを想像して作る」必要はない。現実世界をお手本に、それをマネして作ればよい  
　　・現実世界の登場人物に変化があった場合、対応する部品(クラス)を修正、変換すれば簡単にプログラムを修正できる  
　このようなメリットは、「現実世界をマネる」からこそ生まれてくる。つまり、現実世界の登場人物たちを、コンピュータの中の仮想正解にオブジェクトとして再現し、現実世界と同じように連携して動くようにプログラムを作ることこそがオブジェクト指向の本質である  
- オブジェクトと責務  
・サッカーで考えるオブジェクト指向  
　手続き型とオブジェクト指向との違いをサッカーで比較  
　　手続き型の場合は、11名の選手に的確に指示を出して選手を動かし、相手チームからゴールを奪わなければならない。全選手の一挙手一投足に対して、すべての指示を細かく出す必要がある  
　　オブジェクト指向の場合は、1人ひとりの選手を部品と考え、それぞれの責務(役割や責任)を事前に割り当てられたクラスとして作る。試合が始まったら監督のすることはほとんどなく、仮想世界には、それぞれの選手オブジェクトが生み出され、あとは選手オブジェクト自身が自分の役割を果たしながら他のオブジェクトと連携して動いてくれる  
　それぞれの選手(クラス・オブジェクト)に、「この状況下で、どう行動すべきか」という責務をあらかじめプログラミングしていくため、試合中にそれぞれの選手の一挙手一投足まで支持する必要はなくなる  
　・責務の割り当て  
　　オブジェクト指向プログラミングでは、開発者はそれぞれの部品(クラス)に責務をプログラムとして書き込む  
・オブジェクトの姿  
　仮想世界で動くオブジェクトは、すべて何らかの責務を仮想世界の神様たる開発者から与えられる。たとえば、「サッカー選手」オブジェクトは「ボールを受けたら前に走る」「シュートする」など、あらかじめ設定された役割を果たす行動責任を負っている  
　同様に、ATMの「受付」オブジェクトの場合は、振り込み依頼を受けたら「口座」オブジェクトが管理する2つの口座間でお金を移動し、その結果を「印刷係」オブジェクトに渡してATM利用控えの印刷を依頼するという一連の流れが受付の行動責任となる。「口座」オブジェクトは、行動責任は負っていないが、「残高をしっかり覚えておく」という情報保持責任を負っている  
　このような「情報保持」と「行動」の責任を果たすために、それぞれのオブジェクトは属性と操作を持っている  
　【属性】 その登場人物に関する情報を覚えておく箱  
　【操作】 その登場人物が行う行動や動作の手順  
- オブジェクト指向の三大機能  
・三大機能とその位置付け  
　オブジェクト指向の三大機能  
　　継承:過去に作った部品を流用し、新しい部品を簡単に作れる機能   
　　多様性：似ている2つの部品を「同じようなもの」と見なし、「いいかげんに」利用できる  
　　カプセル化：属性や操作を、一部の相手からは利用禁止にする機能  
  
## インスタンスとクラス  
- 仮想世界の作り方  
・オブジェクトを生み出す手順  
　オブジェクト指向の考え方に沿って開発されたプログラムは、動作時に「現実世界をマネたそれぞれのオブジェクトが、互いに連携して動く仮想世界」を形成する。そのため、開発者の仕事は以下の2つであるといえる  
　①各オブジェクトが負うべき責務を考え、「属性」「操作」の種類と内容を定義する  
　②各オブジェクトを仮想世界に生み出し、動かす  
  
　上記の手順としては、①オブジェクトを定義して、②オブジェクトを生成する、と考えられるが、Javaでは、仮想世界の中で動くオブジェクトそのものを開発者が直接定義することは許されない。その代わりに開発者は、オブジェクトが生み出される際に用いられる、「オブジェクトの設計図」であるクラスを定義できる。よって、正しくは①クラスを定義して、②そのクラスに基づいてオブジェクトを生成する、となる  
・クラスとオブジェクトが別である理由  
　なぜ「クラス定義をして、そのクラスからオブジェクトを生成する」という手順を踏まなければならないのか。それは、オブジェクトを大量に作る必要がある際に、クラスを作成するほうがメリットがあるからである  
　例えば、銀行のシステムですべての口座情報を対象にした複雑な統計プログラムを行う時、仮想世界には口座の数だけ口座オブジェクトが必要となる。口座オブジェクトそれぞれに対して、「属性として、残高・名義人・開設日…」という定義を繰り返すことになる。この作業を、「口座クラス」として1つだけ作っておけば、このクラスから必要な数だけオブジェクトを生み出すことができる  
　注意点として、プログラムの動作時に仮想成果の中で活躍するのは「オブジェクトだけ」であって、その金型であるクラスが仮想世界で活動することは基本的にはない  
・オブジェクトという用語のあいまいさ  
　開発現場における技術的な会話や文章の中で単に「オブジェクト」という表現が用いられる場合、金型か、その金型から生まれた実体かを厳密に区別しないことがある。つまり、「オブジェクト」は。ときどきクラスのことを指して使われることもある。もし、「金型ではなく、その金型から生み出された仮想世界で活動する実体」を厳密に示したい場合は、インスタンスと呼ぶ。また、クラスからインスタンスをせ生する行為をインスタンス化と表現する  
・プログラムに登場する2種類のクラス  
　プログラムを作成するにあたって、必要となるクラスは2種類ある。1つ目は「現実世界の登場人物に対する金型(クラス)」、つまり、その仮想世界で活動する存在のクラス(例：ゲームの勇者キャラや敵キャラなど)だ。しかし、この「登場人物に対するクラス」だけではプログラムは動かない。誰かから指示(操作の呼び出し)をされて責任を果たすために動くので、これだけでは。「指示待ち状態」になってしまう  
　そこで、必要となるのが指示をするクラスである。これはmainメソッドとして記述する。このMainクラスだけは、現実世界を模したものではなく、インスタンス化して利用するものではない。あくまでも仮想世界の神様として、それぞれの登場人物を生み出し、それらに対して支持を出す役割を担っている  
　「勇者とお化けキノコの戦い」というゲームプログラムを作る場合、「勇者」クラスと「お化けキノコ」クラス、Mainクラスの3つのクラスの開発が必要となる  
  
- クラスの定義方法  
・登場人物クラスの作り方  
　クラスには「どのような属性や操作を持っているか」を記述していく。勇者クラスを作成する時、「クラス名：勇者」「属性：名前・HP」「操作：戦う・眠る・座る・転ぶ・逃げる」とする。この時、「クラス名」「属性」「操作」を上から一覧として並べるクラス図(class diagram)で表す。クラス図は、世界共通の設計図であるUML(Unified Modeling Language)で定められている図の1つである  
　・クラス図に基づいて記述したJavaのプログラム)  
　public class Hero {  
　 String name;  
　 int hp;  
　 public void attack() {・・・}  
　 public void sleep() {・・・}  
　 public void sit(int sec) {・・・}  
　 public void slip() {・・・}  
　 public void run() {・・・}  
  }  
  
・クラスの宣言方法  
　クラスの宣言には、classキーワードを使う  
・属性の宣言方法  
　属性の宣言には、その属性について、プログラムで使用する変数名と型をクラスブロックの中に記述する  
・属性の初期値設定と定数フィールド  
　フィールド宣言と同時に値の代入も記述すると、そのフィールドの初期値を設定できる  
　例)  
　public class Matango {  
　 int hp;  
　 int level = 10;  
　}  
  
　また、フィールド宣言の先頭にfinalを付けると、値を書き換えられない定数フィールドになる。定数フィールドの名前は一目でそれと分かるように大文字の記述が推奨される  
　 final int LEVEL = 10;  
  
・操作の宣言方法  
　操作を定義するには、「操作の名前」「操作するときに必要な情報の一覧」「操作の結果として指示元に返す情報」「処理内容」の4つ考える  
　例：「眠る」操作の具体的な要素)  
　【名前　sleep】【必要情報　なし】【結果　なし】【処理内容　HPが100回復する】
　Heroクラスのクラスブロック内の記述例)  
　public void sleep() {  
　 this.hp 100;  
　 System.out.println(this.name + "は、眠って回復した！");
　}  
  
　メソッド内部のthis.hpやthis.nameのthisは特別に準備された変数で、「自分自身のインスタンス」を意味している。また、ドット(.)には、日本語でいう「の」と同じ意味がある。this.hp = 100:は「自分自身のインスタンスのhpフィールドに100を代入する」という意味になる  
・クラス名とメンバ名のルール  
　フィールドとメソッドは、メンバ(member)と総称される。クラス名やメンバ名は、基本的に識別しのルールに沿っていれば自由に決めることができる。しかし、実際には次のような慣例に従って名前を付けるのが望ましいとされる  
　【クラス名　名詞　単語の頭が大文字　Hero、Monsterlnfo】【フィールド名　名詞　最初以外の単語の頭が大文字　level、itemList】【メソッド名　動詞　最初以外の単語の頭が大文字　attack、findWeakPoint】  
  
- クラス定義による効果  
・クラス定義によって可能になる2つのこと  
　Javaでは、クラスを定義すると、次の2つのことが可能になる  
　1.そのクラスに基づいて、インスタンスを生成できるようになる  
　2.そのクラスから生まれたインスタンスを代入する変数の型が利用できるようになる(Heroクラスを定義したとすると、Hero型の変数が利用できるようになる。このクラス定義によって利用可能になる型をクラス型(class type)という)  
・クラス型変数とは  
　Javaで扱うすべての変数は必ず何かしらの型(type)を持っている。「整数を入れるためのint型」や「文字列を入れるためのString型」は、Javaが標準で準備しており、いつでも使える型である。それに加え、Heroクラスのようにクラス定義をすると、「Heroクラスから仮想世界に生み出されたインスタンスを代入できるHero型」が使えるようになる。クラスを定義すればJavaで利用可能な型の種類はどんどん増えていく  
  
　クラス型変数を準備する方法は、int型やString型と同じ  
　Hero h;  
　このHero型の変数hには、上記の段階では勇者インスタンスは入っていないが、今後、「仮想世界に生み出した勇者インスタンス」を代入して利用していく。インスタンスは通常、クラス型変数に入れて利用する  
・クラス型変数が必要な理由  
　なぜ、Hero型の変数にインスタンスを代入するがあるのか。例えば、定義済みのクラスHeroから2つの勇者インスタンス(横並び)を生み出し、どちらも同じ「ミナト」という名前で、HPも同じく100の時に、右側の勇者ミナトに「眠れ」という指示を送るにはどのようにプログラムを記述すればよいのか。紙面では「左のミナト」「右のミナト」と表現できるが、仮想世界中には右も左もないので、2人の勇者を識別する方法がないため、指示を送ることができない。しかし、もし2人の勇者が、それぞれ変数h1とh2に入っているなら問題は解決する。「h2の勇者に眠れという指示を送る」とプログラムを書けばよい  
  
　クラス型変数を用いる理由  
　仮想世界に複数存在しうる同盟インスタンスの中から、特定の1つのインスタンスをプログラムとして識別するため  
  
- インスタンスの利用方法  
・「神様クラス」の作り方  
　Heroクラスだけではプログラムは動かない、動かすには指示を出す「神様のクラス」(Mainクラス)が必要になる。mainメソッドに記述する内容は以下の3つである  
　1.仮想世界に勇者を生み出す  
　2.生み出された勇者に、最初の名前とHPを設定する  
　3.勇者に「5秒座れ」「転べ」「25秒座れ」「逃げろ」などの指示を出す  
・インスタンスの生成方法  
　インスタンスの生成  
　　クラス名 変数名 = new クラス名():  
  　Hero h = new Hero();
　インスタンスを生成しているのは、右辺のnew Hero()の部分。その後、生成したインスタンスを=によってHero型変数hに代入している  
　また、Hero h;、h = new Hero();のように2行に分けて記述する方法もある  
・インスタンスのフィールド利用  
　生み出されたばかりの勇者hには、名前もHPもないのでそれぞれの値にフィールドを代入する  
　フィールドへの値の代入  
　　変数名.フィールド名 = 値;   
　　h.name = “ミナト”  
　　h.hp = 100;  
　　System.out.println(“勇者” + h.name + “を生み出しました！”);
    
　h.name = “ミナト”では変数hのnameにミナトを、h.HP = 100;では変数hのhpに代入して、最後の行で変数hのnameを取り出す  
・インスタンスのメソッド呼び出し  
　「5秒座れ」「転べ」「25秒座れ」「逃げろ」などの指示はそれぞれ、h.sit(5);、h.slip();、h.sit(25);、h.run();のように記述する  
  
　ここで、着目するのは、このmainメソッドの内容が、まるで冒険物語のシナリオのようで分かりやすい点である。オブジェクト指向を学習する前にこの実行結果を得るためには、mainメソッドの中にいくつものHPや計算処理をSystem.out.println()呼び出しを繰り返し記述することになるのでコードの可読性が低くなる。また、オブジェクト指向型では、HPの増減の計算や、画面に表示するメッセージが出てこない。mainメソッドに記述されているのは、勇者を登場させて、座れ、転べ、座れ、逃げろという指示のみであるにも関わらず、動作結果は勇者が行動するたびにHPの増減処理がされ、最終的なHPが125と正しく出力される  
・インスタンス利用のまとめ  
　・インスタンスの生成にはnewを使う  
　・フィールドを利用する場合は変数名.フィールド名と記述する  
　・メソッドを呼び出す場合は変数名.メソッドに名()と記述する  
・オブジェクト指向のクラスは現実世界とつながっている  
　非オブジェクト指向のクラスとオブジェクト指向の考えに沿ったクラスの違い  
　・非オブジェクトのクラス  
　　何を基準にクラスとするか、何を基準にメソッドとするかという明確な思想はない。クラスは現実の事象を模倣したものとは限らない。フィールドやメソッドは開発者の都合で自由に作られる  
　・オブジェクト指向の考え方に沿ったクラス  
　　「オブジェクト指向」という明確な思想に基づいてクラスやメソッドが作られている。クラスは現実世界の登場人物に対応し、その登場人物の「属性」「操作」がそ のまま「フィールド」「メソッド」になる  
  
## さまざまなクラス機構  
- クラス型と参照  
・仮想世界の真の姿  
　ここまでで「Java仮想世界」と表現してきたものは、実際にはコンピュータのメモリ領域のことである。この領域は、Javaプログラム実行時に、JVMがメモリ領域を大量に(通常は数百MB～数GB)使って準備するもので、ヒープ(heap)と呼ばれる  
　そして、newを用いてインスタンスを生み出すたびにヒープの一部の領域(通常数十～数百バイト)が確保され、インスタンスの情報を格納するために利用される。そのため、多くの属性を持った大きなクラスをインスタンス化すると、消費されるヒープ領域は必要とする容量に従って大きくなる。つまり、インスタンスとは「ヒープの中に確保されたメモリ領域」にすぎない  
・クラス型変数とその内容  
　・Step1:Hero型変数の確保  
　　コード上でまず動くのは、クラス型変数を準備する記述のHero h;である。この行を実行すると、JVMは「Hero型の変数h」をメモリ内に準備する。JVMは広いヒープ領域の中から現在利用していないメモリ領域を探し出して確保する。仮に1928番地が空いていたとし、ここが変数h用に確保されたとする  
  この段階ではまだ勇者自体は生まれていない。「Hero型のインスタンスだけを中に入れることができる」Hero型の箱が準備されるだけで、この箱には数値や文字列を入れることはできず、Hero型でない「お化けキノコ」インスタンスを入れることもできない
　・Step2:Heroインスタンスの生成  
　　次に動くのは、代入文であるh = new Hero();である。代入の場合は左辺よりも右辺が評価されるから、まず、new Hero()の部分だけを考える。new Hero()が実行されると、JVMはヒープ領域から必要な量のメモリを確保する。仮に「3922番地から24バイト分(3922～3945番地)」が確保されたとする  
  この段階で、勇者という存在が仮想世界に生まれた。しかし、まだHeroインスタンスの「名前」は空っぽ、「HP」は0である  
　・Step3:参照の代入  
　　変数hに入るもの厳密に言うと、勇者インスタンスの情報が書き込まれた「メモリの先頭番地」が入る。今回の場合、new Hero()により、勇者インスタンスが3922～3945番地に生成されているので、変数hには3922という数値が代入される  
　　変数hに入っている3922は、ただの数値にすぎない。Heroインスタンスに関する名前やHPなどのさまざまな情報は変数hの中ではなく、別のところにある。見方を変えれば、「この変数hにはHeroインスタンスの情報の全部は入りきらないから、詳しくは3922番地を参照して」と解釈できる。このことから、変数hに入っているアドレス情報を参照という  
　・Step4:フィールドへの値の代入  
　　h.hp = 100;では、変数hに格納されている勇者のHpを100に設定する。この行をJVMは次のように解釈し、実行する  
　　　①変数hの内容を調べると、「3922番地を参照せよ」と書かれている  
　　　②メモリ内の3922番地にあるインスタンスのメモリ領域にアクセスし、その中のhpフィールド部分を100に書き換える  
　　このように、まず変数から番地情報を取り出し、次にその番地にアクセスする、というJVMの動作を参照の解決やアドレス解決という  
・同一インスタンスを指す変数  
　仮想世界に勇者が2人生成され、それぞれh1、h2という変数に格納されているとする。勇者h1のhpフィールドを10減らしても、勇者h2のhpフィールドの値は減らない。この同じクラスから生まれても、異なるインスタンスであればお互いに影響を受けないことをインスタンスの独立性という  
  
　　public class Main {
  　　public static void main(String[] args) {
    　　Hero h1;
    　　h1 = new Hero();
    　　h1.hp = 100;
    　　Hero h2;
    　　h2 = h1;
    　　h2.hp = 200;
    System.out.println(h1.hp);
   }
}
　　
  上記のプログラムを正しく理解するためのポイントはh2 = h1である。これは変数1の内容をh2にコピーする文であり、ここでコピーされているのは「勇者インスタンスそのもの」ではなく,
  「3922」のような番地などの情報である。代入の結果、h1とh2の両方に番地情報「3922」が入る。従って、h1とh2はどちらも「まったく同じ1人の勇者インスタンス」を指している。そのため、h1のhpフィールドへ代入しても、h2のhpフィールドへ代入しても、結局は勇者インスタンスのHPに代入することになる  
・クラス型をフィールドに用いる  
　// まず、Swordクラスを定義しておく  
　public class Sword {  
  　String name;  
  　int damage;  
　}  
  
　// 次にHeroクラスを定義する  
　public class Hero {  
  　String name;  
  　int hp;  
  　Sword sword;  
  　public void attack() {  
    　System.out.println(this.name + "は攻撃した！");  
    　System.out.println("敵に5ポイントのダメージをあたえた！");  
  　}  
　}  
  
　Heroクラスに新しく追加されたフィールド「sword」はint型やString型ではなくSword型である。このように、フィールドに型の変数を宣言することもできる。また、今回の例のように「あるクラスが別のクラスが別のクラスをフィールドとして利用している関係」をhas-aの関係という。「has-a」と呼ぶ理由は、Hero has-a Swordのような英文が自然に成立するからである  
　上記のコードを利用するMainクラス  
　public class Main {  
  　public static void main(String[] args) {  
    　Sword s = new Sword();  
    　s.name = "炎の剣";  
    　s.damage = 10;  
    　Hero h = new Hero();  
    　h.name = "ミナト";  
    　h.hp = 100;  
    　h.sword = s;  
    　System.out.println("現在の武器は" + h.sword.name);  
  　}  
　}  
・クラス型をメソッド引数や戻り値に用いる  
　クラス型はフィールドの型に用いるだけでなく、メソッドの引数や戻り値の型としても利用できる。例として、魔法使い(Wizard)クラスを作成する  
　public class Wizard {  
  　String name;  
  　int hp;  
  　public void heal(Hero h) {  
    　h.hp += 10;  
    　System.out.println(h.name + "のHPを10回復した！");  
  　}  
　}  
  
　healメソッドが呼び出されると、魔法使いインスタンスは勇者のHPを10回復させる。ただし、仮想世界には勇者が2人以上生み出されている(2回以上newされている)場合もあるため、呼び出される時に「どの勇者を回復させるのか」を引数hとして受け取る必要がある((Hero h)で指定)  
・String型の真実  
　String型は、int型やdouble型の中ｍではなく、Hero型と同じ「クラス型」である。Stringクラスを定義していないにもかかわらず、String型を利用できている理由は、MathクラスやSystemクラスのようにAPIとして標準添付されている膨大な数のクラス中に、Stringクラス(正式名称：java.lang.Stringクラス)が含まれているからである  
　これまでString型を「int型と似たようなもの」として扱い続け、Javaが準備してくれていたクラスだと気付かなかった理由は、Javaというプログラミング言語が作られる時に、次のような特別な配慮がされたためである  
　①java.langパッケージに宣言されている  
　　java.langパッケージに所属するクラスを利用する場合、特例としてimport文を記述する必要がない。本来はjava.lang.String s;と宣言する必要があるが、単にString s;と書けば利用できるようになっている  
　②二重引用符で文字列を囲めばインスタンスを生成して利用できる  
　　通常、インスタンスを生成するにはnew演算子を利用する必要があるが、文字列はプログラムの中で多用されるため、その都度newを書くとソースコードが「newだらけ」になってしまう。そこで「二重引用符で文字列を囲めば、その文字列情報を持ったStringインスタンスを利用できる」という特例が設けられた。new演算子を使うことなくStrings = "こんいちは";というシンプルな記述が可能になっている  
　Stringもクラスに違いはないので、HeroやSwordと同じようにnewでインスタンスを生成することもできるが、効率が悪いので、通常は利用しない  
  
- コンストラクタ  
・生まれたてのインスタンスの状態  
　newでインスタンスを生成した直後、必ずフィールドの初期値を代入しているのは、newで生み出されたばかりのインスタンスのフィールド(nameやhp)には、まだ何も入っていないからである。厳密に言えば、各フィールドには値が「入っていない」のではなく、次のような初期値が設定されている  
　フィールドの初期値  
　int型、short型、long型などの数値に型　　0  
　char型(文字)　　¥u0000  
　boolean型　　false  
　int[]型などの配列型　　null  
　String型などのクラス型　　null　　
・フィールド初期値を自動設定する  
　実際の開発現場において、自分以外の開発者が同じクラスを利用する場合もある。そして、それぞれの開発者が同じ値を代入するとは限らない(今回のRPGの場合、HPに100を代入)。また、初期化を忘れてしまう場合もある。他にもそのクラスを作成した人が想定しないような数、例えば負の数や非常に大きな数で初期化してしまうかもしれない。こうなるとプログラムが正しく動作しない場合がある。このような場合に備え、Javaでは「インスタンスが生まれた直後に自動実行する処理」をあらかじめ定義できるようになっている  
　public class Hero {  
  　String name;  
  　int hp;  
  　Sword sword;  
  　public void attack() {  
    　System.out.println(this.name + "は攻撃した！");  
    　System.out.println("敵に5ポイントのダメージをあたえた！");  
  　}  
  　public Hero() {  
    　this.hp = 100;    // hpフィールドを100で初期化  
  　}  
　}  
  
　このクラスにはHero()というメソッドが追加されている。attack()などの通常のメソッドは誰かから呼ばれないと動かないが、Hero()だけは、このクラスがnewされた直後に自動的に実行されるという特別な性質を持っている。このようなメソッドをコンストラクタ(constructor)と呼ぶ。Hero()はコンストラクタとして定義されており、newされると自動的に実行されてHPに100が代入される。そのため、mainメソッド側でHPに初期値を代入する必要がない  
　Hero h = new Hero();でインスタンス生成と同時にコンストラクタによってHPに100が代入される  
　ここで意識しなければならないのは、コンストラクタは、私たち開発者が直接呼び出すものではないという点である。私たちが行うのはあくまでもHero h = new Hero();でインスタンスを生成することであって、インスタンス生成の完了後にJVMがHero()を自動的に実行してくれる。h.Hero();のように私たちがコンストラクタを直接呼び出すことはできない  
・コンストラクタの定義方法  
　一見すると、コンストラクタであるHero()も、他のメソッドとは違いはないように見える。しかし、newでインスタンスを生成した時に自動実行されるのはHero()だけである。実はJavaでは、クラスに記述されているメソッドのうち、次の条件を満たすメソッドだけがコンストラクタとみなされ、自動実行される決まりになっている  
　コンストラクタと見なされる条件  
　　①メソッド名がクラスメイト完全に等しい  
　　②メソッド宣言に戻り値の型が記述されていない(voidも含む)  
　Hero()がコンストラクタとして実行されたのは、「Heroクラス」の中に完全に同名である「Hero()」として定義されており、その戻り値が記述されていないからである  
  
　コンストラクタの定義  
　public class クラス名{  
　　public クラス名() {  
　　　自動的に実行する処理  
　　}  
　}  
  
　100などの固定値を代入するだけならば、コンストラクタを用いずにフィールド宣言をint hp = 100;としても対応できる。しかし、複雑な条件で初期化したい場合は、コンストラクタを使わなければ実行できない  
・コンストラクタに情報を渡す  
　HPフィールドは固定の値で初期化すればよいため、単純なコンストラクタで済んだが、勇者の名前は生み出すインスタンスによって異なる。このようなケースでは、コンストラクタが「毎回異なる追加情報」を引数で受け取れるように宣言する  
　public class Hero {  
  　String name;  
  　int hp;  
  　Sword sword;  
  　public void attack() {  
    　System.out.println(this.name + "は攻撃した！");  
    　System.out.println("敵に5ポイントのダメージをあたえた！");  
  　}  
  　public Hero(String name) {  
    　this.hp = 100;  
    　this.name = name;    // 引数の値でnameフィールドを初期化  
  　}  
　}  
  
　私たちは直接コンストラクタを呼べないため、引数を直接渡すことはできない。しかし、JVMに対して、newするときに「コンストラクタを呼ぶときはこの情報使って」とお願いすることができる  
  
　public class Main {  
  　public static void main(String[] args) {  
    　Hero h = new Hero("ミナト");  
    
    　System.out.println(h.hp);  
    　System.out.println(h.name);  
  　}  
　}  
  
　Hero h = new Hero("ミナト"); でインスタンス生成後、JVMがコンストラクタを呼び出す際に「ミナト」を渡してもらえる  
・2つ以上の同盟コンストラクタを定義する  
　現在のHeroクラスには、「文字列の引数を1つ受け取るコンストラクタ」が定義されている。そして、コンストラクタはnewされたときに必ず自動的に実行されるものだから、newする側として、必ず引数となる文字列を1つ与える必要がある  
　このコンストラクタを作ったことによって、インスタンスを生成する時には、必ず名前を指　定する必要が生じた。引数なしでnew Hero()を実行するとエラーになる。この問題は
「引数を受け取らないコンストラクタ」も同時に定義すれば解決できる  
  
　public class Hero {  
  　String name;  
  　int hp;  
  　Sword sword;  
  　public void attack() {  
    　System.out.println(this.name + "は攻撃した！");  
    　System.out.println("敵に5ポイントのダメージをあたえた！");  
  　}  
  　public Hero(String name) {　(以前からあったコンストラクタ①)  
    　this.hp = 100;  
    　this.name = name;    // 引数の値でnameフィールドを初期化  
  　}  
  　public Hero() {　(新しく作ったコンストラクタ②)  
    　this.hp = 100;  
    　this.name = "ダミー";　(ダミーの名前を設定する)  
  　}  
　}  
  
　複数のコンストラクタが定義されていた場合  
　　newする時に渡した引数の型・数・順番に一致するコンストラクタ1つだけが動作する  
・暗黙のコンストラクタ  
　コンストラクタのないHeroクラスはnew Hero();で生成できたのに、引数ありコンストラクタの定義では不可能になっている。Javaでは、すべてのクラスはインスタンス化に際して必ず何かしらのコンストラクタを実行する決まりになっている。そのため、すべてのクラスは最低でも1つ以上のコンストラクタを持っていなければならない  
  
　コンストラクタの特例  
　　クラスに1つもコンストラクタが定義されていない場合に限って、「引数なし、処理なし」のコンストラクタ(デフォルトコンストラクタ)がコンパイル時に自動的に追加される  
  
　コンストラクタを定義する前のHeroクラスは、この特例によって引数なしのコンストラクタがこっそり自動的に定義されていたため、new Hero();によるインスタンス化が可能だった。しかし、新たに引数を1つ含むコンストラクタを定義した時点でこの特例が適用されなくなり、new Hero();によるインスタンスの生成は出来なくなる  
・ほかのコンストラクタを呼び出す  
　コンストラクタを2つ以上生成すると内容に重複がある場合がある(「2つ以上の同盟コンストラクタを定義する」のコード)。2つのコンストラクタは、どちらもHPに100を代入している。しかし、将来、初期HPを200に変更するなどの使用があったら、コンストラクタ①と②の両方を少雨性する必要が生じる。そこで思いつくのが、次のようなHPへの代入を1か所に集めるといった、コンストラクタ②の中でコンストラクタ①を呼び出す方法だ  
  
　public class Hero {  
  　String name;  
  　int hp;  
  　Sword sword;  
  　public void attack() {  
    　System.out.println(this.name + "は攻撃した！");  
    　System.out.println("敵に5ポイントのダメージをあたえた！");  
  　}  
  　public Hero(String name) {    // コンストラクタ①  
    　this.hp = 100;  
    　this.name = name;  
  　}  
  　public Hero() {    // コンストラクタ②  
    　this.Hero("ダミー");  
  　}  
　}  
  
　しかし、このコードはコンパイルエラーになる。なぜなら、コンストラクタを呼び出せるのはJVMだけであり、私たちが直接呼ぶのは許されていないためだ。だが、次の構文によって、JVMにコンストラクタの起動を依頼することが可能である  
　別コンストラクタの呼び出しをJVMに依頼する  
　this(引数);  
  
以下はこの構文を用いて、書き直したコードである  
  
　public class Hero {  
  　String name;  
  　int hp;  
  　Sword sword;  
  　public void attack() {  
    　System.out.println(this.name + "は攻撃した！");  
    　System.out.println("敵に5ポイントのダメージをあたえた！");  
  　}  
  　public Hero(String name) {    // コンストラクタ①  
    　this.hp = 100;  
    　this.name = name;  
  　}  
  　public Hero() {    // コンストラクタ②  
    　this("ダミー");　(コンストラクタ①を呼び出すようJVMに依頼する)  
  　}  
　}  
  
　*this()は前章のthisと似ているが別物である。this.メンバ名のthisは自分自身のインスタンスを表すもの、this(引数)は同一クラスの別コンストラクタを呼び出すためのものである  
  
## 継承  
- 継承の基礎  
・似かよったクラスの開発  
　Javaで大きなプログラムを作り始めると「ほとんど同じだけれどフィールドが2つ多い」「ほとんど同じだけれどメソッドが1つ多い」などのような、以前作ったクラスと似かよったクラスを作る必要に迫られる場合がある  
　作成中のゲームプログラミングのHeroは冒険するにつれ進化していき、次のような能力を持ったSuperHeroという職業になれるとする  
　・スーパーヒーローはfly()で空を飛ぶことができ、land()で着地できる  
　・ヒーローができるすべての動作は、スーパーヒーローもできる  
  
　Heroクラスを元にSuperHeroクラスを開発する時、Heroのコードをコピー&ペーストしてクラス名をSuperHeroに変更して、それにfly()とland()のメソッドを足せば完成する  
・「コピペ解決法」の問題点  
　元となるコードをコピー&ペーストして、新しい機能を追加すれば、簡単に元のクラスを発展させることができる。解決方法としては、とてもシンプルで、コードも問題なく動作するだろう  
　しかし、この方法によって作成されたSuperHeroクラスには、次のような2つの問題がある  
　①追加・修正に手間がかかる  
　　Heroクラスに新しいメソッドを追加する、またはHeroクラス内のメソッドを変更する場合、それをSuperHeroクラスにも行う必要がある。なぜなら、Heroができることは、SuperHeorもできるからである  、②把握や管理が難しくなる  
　　SuperHeroクラスはHeroクラスをコピーして作っているため、この2つのクラスのソースコードの大半が重複している。これによりプログラム全体の見通しが悪くなり、メンテナンスがしづらくなる  
  
　今後、Heroクラスを元にした別のクラス(HyperHeroやLegendHero、MagicHeroなど)を作る必要が出てくるかもしれない。すると、Heroクラスに変更があるたびに、すべての～Heroクラスに対してHeroクラスと同じ修正を行う必要が生じる  
・継承による解決  
　「コピペ解決法」を用いて類似してクラスを作成していくと、将来、元となったクラスが変更されたら、すべての類似クラスも修正を必要とする。しかし、Javaには、このようなコードの重複を懸念することなく類似したクラスを作成できる機能、継承がある。これを使えば、SuperHeroクラスをスッキリと記述できる  
  
　public class SuperHero extends Hero {  
  　boolean flying;  
  　public void fly() {  
    　this.flying = true;  
    　System.out.println("飛び上がった！");  
  　}  
  　public void land() {  
    　this.flying = false;  
    　System.out.println("着地した！");  
  　}  
　}  
  
1行目のpublic class SuperHero extends Heroという宣言は、「HeroクラスをベースにしてSuperHeroクラスを定義するので、Heroと同じメンバの定義は省略します(違いだけ記述します)」という意味になる  
　継承を用いたクラスの定義  
　public class クラス名 extends 元となるクラス名 {  
　　親クラスとの差分となるメンバ  
　}  
  
　このSuperHeroクラスがインスタンス化される時に、JVMは、省略されているけれども、SuperHeroクラスはHeroクラスに含まれているname、hp、attack()、run()、も持っていると判断する。従って、SuperHeroクラスのソースコードにrun()はないが、インスタンス化されればrun()を呼び出すことができる  
　SuperHeroを生み出してrun()を呼び出すコード
　　public class Main {  
  　　public static void main(String[] args) {  
    　　SuperHero sh = new SuperHero();  
    　　sh.run();  
  　　}  
　　}  
  
このように、extendsを用いて、元となるクラスとの「差分」だけを記述して新たなクラスを宣言できる。新たに定義するクラス(SuperHero)に着目すると、元となるクラス(Hero)から、メンバが自動的に引き継がれているように見えることから、「継承」という名前が付いている  
・継承関係の表現方法  
　Heroクラスを継承してSuperHeroクラス作ったように、この2つのクラス関係を継承関係という。そして、元となるクラスを「スーパークラス」「基底クラス」「親クラス」などと呼び、新たに定義されるクラスを「サブクラス」「派生クラス」「子クラス」などと呼ぶ  
　継承関係を図で表現する場合、新たに定義されるクラスから元となるクラスに向かって矢印で記述する  
・継承のバリエーション  
　継承は、2つのクラスの関係を表すだけではない。バリエーションとして、1つのクラスをベースとして、複数の子クラスを定義することもできるし、孫クラスや曾孫クラスの定義も可能である  
　ただし、Javaで唯一許されていない継承の構図が、多重継承という複数のクラスを親として1つの子クラスを定義する構図である  
・オーバーライド  
　SuperHeroのrun()の動きを変えたい場合、SuperHeorクラスのコードに新しいrun()を記述することで解決できる。親クラスであるHeroにもrun()はあるが、子クラスSuperHeroでも改めてrun()を定義する  
　親クラスを継承して子クラスを宣言する際に、親クラスのメンバを子クラス側で上書きすることを、オーバーライド(override)という  
  
　継承を用いて子クラスに宣言されたメンバの扱い  
　①親クラスに同じメンバがなければ、そのメンバは「追加」扱いされる  
　②親クラスに同じメンバがあれば、そのメンバは「上書き」される  
・継承やオーバーライドの禁止  
　Javaでは、宣言にfinalが付けられているクラスは継承できないことになっている(Stringクラス(java.lang.String)など)  
　自分で作成するクラスにもfinalを付ければ「継承禁止」にできる(クラス宣言にfinalを追加する)  
　また、クラスの継承は許可するものの、一部のメソッドについてのみオーバーライドを禁止したい場合は、そのメソッドにfinalを付ける。宣言にfinalが付けられたメソッドは、子クラスでオーバーライドができないことになっている
  
　継承やオーバーライドの禁止  
　・クラス宣言にfinalを付けると、継承を禁止できる  
  ・メソッド宣言にfinalを付けると、オーバーライドを禁止できる  
  
- インスタンスの姿  
・インスタンスの多重構造  
　より踏み込んで継承を使いこなすには、継承を用いて定義されたSuperHeroのようなクラスから生まれたインスタンスが、実際にどのような姿をしていて、どのようにふるまうかを理解しておくことが重要である  
　SuperHeroクラスは、外から見れば1つのSuperHeroインスタンスだが、内部にHeroクラスから生まれたHeroインスタンスを含んでいるので、全体として二重構造になっている
　ここからは、外側の部分を「子インスタンス部分」、内側の部分を「親インスタンス部分」と呼び、このイメージ図を通してさまざまな呼び出しや動作のしくみを考える  
・メソッドの呼び出し  
　インスタンスの外からメソッドの実行依頼が届く(呼び出しがある)と、多重構造のインスタンスは、極力、外側にある子インスタンス部分のメソッドで対応しようとする  
　たとえば、fly()が呼び出されればSuperHeroクラスで定義されたfly()が動く。一方、attack()への呼び出しは、まずは外側の子インスタンス部分で対応しようとするが、外側にattack()は存在しない。そこで内側にある親インスタンス部分のattack()に呼び出しが届き、それが動作する  
　run()は、SuperHeroとHeroの両方のクラスの定義で(オーバーライド)されており、SuperHeroインスタンスは「SuperHeroとして逃げ方」と「Heroとして逃げ方」の両方を持っている。この状態でrun()を呼び出された場合、外側にあるSuperHeroとしてのrun()が優先的に動作するため、内側のrun()が動くことはない  
・親インスタンス部へのアクセス  
　頻度としては多くは無いが、内側の親インスタンス部分に属するメソッドが活躍することがある。たとえば、次のような例を考える  
　SuperHeroの追加仕様  
　SuperHeroは、空を飛んでいる状態でattack()すると、Heroでは1回だった攻撃を2階連続で繰り出すことができる  
  
　これを実現するには次のようなオーバーライドを思いつくかもしれない  
　public class Hero {  
  　String name = "ミナト";  
  　int hp = 100;  
  
  　public void attack(Matango m) {  
    　System.out.println(this.name + "の攻撃！");  
    　m.hp -= 5;  
    　System.out.println("5ポイントのダメージをあたえた!");  
  　}  
  　public final void slip() {  
    　this.hp -= 5;  
    　System.out.println(this.name + "は転んだ!");  
    　System.out.println("5のダメージ");  
  　}  
  　public void run() {  
    　System.out.println(this.name + "は逃げ出した！");  
  　}  
　}  
  
　しかし、この方法では、将来Heroクラスのattack()の処理内容が変わった場合に困った事態に陥る  
　たとえば、Heroクラスのattack()が修正され、1回の攻撃で敵に与えるダメージが10に修正されたとする。SuperHeroインスタンスを生み出し、fly()を呼び出した後でattack()を呼び出したらどうなるか  
　このような場合には、内部で親インスタンスのメソッドを呼び出せれば果たせ、次のように記述する  
　public class Hero {  
  　String name = "ミナト";  
  　int hp = 100;  
    
  　public void attack(Matango m) {  
    　System.out.println(this.name + "の攻撃！");  
    　m.hp -= 5;  
    　System.out.println("5ポイントのダメージをあたえた!");  
  　}  
  　public final void slip() {  
    　this.hp -= 5;  
    　System.out.println(this.name + "は転んだ!");  
    　System.out.println("5のダメージ");  
  　}  
  　public void run() {  
    　System.out.println(this.name + "は逃げ出した！");  
  　}  
　}  
  
　superとは、「今より1つ内側のインスタンス部分」を表す予約語である。これを利用すれば、親インスタンス部分のメソッドやフィールドに子インスタンス部分からアクセスできる  
  
　親インスタンス部分のフィールドを利用する  
　super.フィールド名  
　子インスタンス部分のメソッドを呼び出す  
　super.メソッド名(引数)  
  
　もし、superを付けずにattack()だけで呼び出してしまうと、this.attack()と書いたのと同じ意味になってしまう。thisは「自分自身のインスタンス」を意味するが、より正確には、「インスタンスの最も外側の部分」を指す。そのため、自分自身のattack()を呼び出し続ける無限ループが生じてしまう  
  
- 継承とコンストラクタ  
・継承を利用したクラスのコンストラクタ  
　インスタンス化されたSuperHeroは、Heroインスタンスを内部に持つ多重構造になっている。この多重構造は、クラスがnewされると、次のような段階を経て構築される  
　new SuperHero() 
　①まず、親インスタンス部が作られる(Hero)  
　②外側に子インスタンス部が作られる(SuperHero)  
　③JVMにより自動的にコンストラクタが呼ばれる(SuperHero())  
  
　SuperHeroインスタンスが完成すると、JVMは自動的にSuperHero()コンストラクタを呼び出す。ここでSuperHeroをnewするとSuperHero()コンストラクタが動作するだけでなく、内側のHero()コンストラクタも勝手に動作する。Javaでは、すべてのコンストラクタは、そお戦闘で必ず内部インスタンス部分(親クラス)のコンストラクタを呼び出さなければならないと決まっている  
　同じクラスの別のコンストラクタを呼び出すためのthis()に似たSuper()という記述で親クラスのコンストラクタを呼び出せる  
  
　親クラスのコンストラクタの呼び出し  
　super(引数);  
　*コンストラクタの先頭に記述する必要がある  
  
　よって、SuperHeroコンストラクタは次のような書き方をする  
　public SuperHero() {  
　　super();  
　　~  
　}  
  
　もしコンストラクタの1行目でsuper()を呼び出さないと、コンパイラによってsuper();という行が自動的に挿入されるので、「暗黙のsuper()」が、自動的にHero()コンストラクタを呼び出すことになる  
・親インスタンス部分が作れない理由  
　インスタンスが構築、初期化される過程を理解すると、会う条件で困ったことが発生する  　
　public class Item {  
  　String name;  
  　int price;  
  　public Item(String name) {  
    　this.name = name;  
    　this.price = 0;  
  　}  
  　public Item(String name, int price) {  
    　this.name = name;  
    　this.price = price;  
  　}  
　}  
  
　public class Weapon extends Item { /* … */ }  

　public class Main {  
  　public static void main(String[] args) {  
    　Weapon w = new Weapon();  
  　}  
　}  
  
　Main.javaの3行目のnew Weapon()により、JVMはWeapon()インスタンスを生成しようとする。WeaponクラスはItemクラスを継承しているので、このインスタンスは内部にItemインスタンスを含む多重構造になっているはずである  
　二重構造のインスタンスを繕えると、JVMは自動的にWeapon()コンストラクタを呼び出そうとする。しかし、Weaponクラスにはコンストラクタが定義されていないため、暗黙的に次のような「デフォルトコンストラクタが定義され動作する  
　public Weapon() {  
　}  
  
　しかｓ、すべてのコンストラクタの先頭行にはsuper();が隠れているので、実際には次のようになる  
　public Weapon() {  
　　super();  
　}  
  
　このように自動生成されたWeaponクラスのコンストラクタは、親クラスItemのコンストラクタを引数なしで呼ぼうとする。ここで、呼び出される側のItemクラスのコンストラクタの宣言を見てみると、引数1つのものと2つのもの合わせて2つのコンストラクタが宣言されているが、引数0個のコンストラクタは存在しない  
　つまり、Itemクラスのコンストラクタ呼び出しには、必ず引数が1つか2つ必要であり、Weaponクラスのコンストラクタからであっても、super();のように引数がない呼び出しはできない  
・内部インスタンスのコンストラクタ引数を指定する  
　内部インスタンスの初期化を行うコンストラクタ(Item()コンストラクタ)に引数を与える必要がある場合は、super()の呼び出しで明示的に引数を渡す  
　public class Weapon extends Item {  
　　public Weapon() {  
　　　super("ななしの剣");  
　　}  
　}  
  
　これで、weaponクラスのインスタンス化によって内部でItemインスタンスが作られるタイミングで、Item.javaのコンストラクタが動作し、常に「ななしの剣」という名前になる。また、super("ななしの剣", 300);と記述すれば、常にコンストラクタが動作する  
　つまり、super()に与える引数の数と型によって、「親インスタンス部分が初期化されるときに利用されるコンストラクタ」を明示的に指定される  
   
- 正しい継承、間違った継承  
・is-aの原則  
　正しい継承とは、「is-aの原則」と呼ばれるルールに則っている継承のこと。そしてis-aの原則とは、子クラスと親クラスの間に次のような概念的な関係が成立しているべきとする原則である  
　is-aの関係  
　子クラスis-a親クラス(子クラスは、親クラスの一種である)  
  
　スーパーヒーローは特殊能力を持った特別なヒーローだが、あくまでもヒーローの一種である。「SuperHero is-a Hero」と言えるから、正しい継承である  
　もし、子クラスis-a親クラス(子クラスは親クラスの一種である）toiubunnsyouniあてはめて不自然さを感じたら、継承の誤りを疑う  
・間違った継承の例  
　現実世界の登場人物同紙に概念としてis-aの関係がないにも関わらず、継承を使ってしまうのが「間違った継承」である  
　例えば、「名前」と「値段」のフィールドを持つItemクラスがあるとする。このクラスは、勇者たちが冒険のために持ち歩く「薬草」や「ポーション」などのアイテム(小道具)を表すクラスである。そして今、新たにHouseクラスを作ろうとするとする。Houseクラスには、所有者や床面積、間取りや住所などの他、「家の名前」「家の値段」のフィールドが必要となる  
　Itemクラスを継承してHouseクラスを作るのは、文法上はもちろん可能だ。名前と値段のフィールドも継承され、問題なく動作する。しかし、「House is-a Item」(家はアイテムの一種である)という文章には違和感がある。勇者は冒険のために家を持ち歩くことはないからである  
　このように、「フィールドやメソッドが流用できるから」という安易な理由で継承をしてはいけない。「動くか動かないか、便利か便利でないか」ではなく、is-aの関係であるかどうかに基づいて継承は利用すべきである  
　間違った継承は行わない  
　is-aの原則が成立しないならば、ラクができるとしても継承してはならない  
・間違った継承をすべきではない理由  
　is-aの関係でない継承をしてはいけない理由は2つある  
　・将来、クラスを拡張していった場合に現実世界との矛盾が生じるから  
　・オブジェクト指向の三大機能の1つ「多様性」を利用できなくなるから  
  
　Houseクラスを作った時点では、Itemクラスを継承していても問題ないように思える。しかし、これは単にたまたま現時点では実害がないだけであって、より忠実に現実世界の家やアイテムをまねようとクラスを改良していくと、次々と矛盾が生じていく  
　たとえば、アイテムは敵に投げつけてダメージを与えられるとする。そこで、Itemクラスに敵に投げつけた時に与えるダメージを返すメソッドであるgetDamage()を追加する  
  
　public int getDamage() {  
　　return 10;  
　}  
  
　このメソッドは継承されてHouseクラスでも利用可能になるが、現実に沿って考えると家を投げることが出来るわけがないし、そのダメージを算出する、getDamageメソッドがHouseクラスに対して呼べること自体が極めて不自然である  
　「投げつけたときのダメージがある家」を表すHouseクラスは、すでに現実世界の「家」と乖離しており、オブジェクト指向の原則から外れている  
・ 汎化、特化の関係  
　正しい継承がis-aの関係で結ばれるという事実は、子クラスになるほど「特殊で具体的なもの」に具体化(特化)していき、親クラスになるほど「抽象的であいまいなもの」に一般化(汎化)していくことを示す。特化すればするほど、より詳細にフィールドやメソッドを定めるため、メンバは増えていく。逆に汎化すればするほど、、フィールドやメソッドを定めるのは難しくなっていく  
　例えば、キャラクターであれば必ず名前とHPは持っているから、Characterクラスにはnameとhpフィールドは定義できる１。より、具体的なキャラクターとして、魔法使いになると最低でもMPを持っていて火の玉は放てるとすると、クラス定義にはmpフィールドやfireballメソッドが加わる。さらに具体的な「ひとにぎりの大魔法使い」(GreatWizard)は雷を落とすlightningメソッドなど、Wizardが持っていないメソッドを持つ、継承関係を表す図を継承ツリーなどと呼ぶ  
　継承は、重複するコードの記述を減らすための道具だけでなく、ある2つのクラスに特化・汎化の関係があることを示すための道具でもある  
  
## 高度な継承  
- 未来に備えるための継承  
・高度な継承を学ぶにあたって  
　正しい継承はクラス間の特化・汎化の関係を表す。そして、継承ツリーを親クラス、その親クラス、さらにその親クラス…と辿っていくほど、クラスはあいまいで抽象的なものになる。この章では、主に、継承ツリーの上方に登場する「あいまいなクラスたち」の定義方法について学ぶ。これまで学んできた方法でこれらのクラスを定義しても、プログラムは動作する。しかし、「あいまいなクラスたち」専用のクラス定義方法を理解し、高度な継承を実現すれば、より安全に便利にクラスを利用できる  
　継承はすぐに理解できたのに、高度な継承でつまづくケースも珍しくない。高度な継承をスムーズに理解するには、これまで持っていたある意識を切り替える必要がある  
・新しい「立場」で考える  
　高度な継承は、文法的に難しいものではない。それにも関わらずつまづく人が多い理由は、高度な継承を使うときの「立場」が、これまでの「立場」とはまったく違うということを意識せずに学習を始めてしまうからである  
　今までは、作る必要がある(または作りたい)プログラムは明確に決まっていて、そのプログラムのためだけに必要なクラスを作って目的のプログラムを完成させる「立場」が多かった。そして、もし開発すべきクラスと類似した「既存のクラス」があれば、継承を利用して子クラスを作ることにより、一から開発せずとも、いくつかのメンバを追加するだけで効率よくクラスを開発できる。ここで、「既存クラス」に注目すると、このクラスを事前に開発しておいてくれた開発者がどこかにいるはずだ。その作者は、自分の作ったクラスがどんなプログラムに利用されるか想像もつかない過去の段階で、「いつか誰かが、このクラスを継承して開発したら便利だろう」と未来に思いを馳せ、継承の材料となる既存クラスを作ってくれたのである  
　ここで、異なる「立場」で活躍する2種類の開発者がいることがわかる  
　　立場1：現在、目の前のプログラム開発に必要なクラスを作る開発者(既存クラスを継承して子クラスを作る)  
　　立場2；未来に備え、別の開発者が将来利用するであろうクラスを準備しておく開発者(親クラスとなるクラスを作っておく)  
　この賞の内容をスムーズに理解するためには、この2つの立場の存在を明確に意識し、区別できるかがポイントになる。前章までに学習してきた知識はすべて、立場1として開発するに必要なものだ。一方、この章で学習する知識は、立場2としてプログラムを作るときに必要となるものである。この章で学ぶ「抽象クラス」「インタフェース」とは、立場2の人たちが、立場1の人たちに安全で便利に使ってもらえる親クラスを作るための道具だからである  
・「未来に備える開発者」の立場  
　ゲーム開発を例に考える。プロジェクトではAさん、Bさん、Cさんと自分の4人で開発を進めているが、ある日、開発効率が悪いことが問題になった。そこで、プロジェクト全体の開発効率を改善する責任者に任命され、調査したところ、開発者がそれぞれ、HeroやWizardなどの似たクラスを一から作っていることに気づいた。各キャラクターのクラスでは、nameやhpなどのフィールドと、attack()、run()などのメソッドは共通なので、それどれ別に開発するのは非効率である。また、今後のバージョンアップにより「商人」や「占い師」など、さまざまな職業のキャラクターが増える予定だが、それも一から開発していては効率が悪い  
　そこで、各クラスに共通するフィールドやメソッドを持つCharacterクラスを準備すると、他の開発者はCharacterクラスを継承して、独自のフィールドやメソッドを付け足すだけで済むので効率が良くなる。このとき、Characterクラスを準備した人は「今すぐ必要な、実際に利用されるクラス」を作っている開発者(立場1)ではなく、「未来に備えて、継承元となるクラス(継承の材料)」を作るという立場(立場2)にあたる。後方支援の道具(共通部分まで事前に作っておいたCharacterクラス)を供給して援護している、とも捉えられる  
　たった1つのクラスの優劣が、それを利用する複数の開発者たちの開発効率に影響する。立場2の時に意識すべきことは、立場1の開発者が効率よく安心して利用できる継承の材料をいかに作るかというポイントに絞られる  
  
 「未来に備える開発者」の役割  
　ほかの開発者が効率よく安心して利用できる継承の材料をつくること  
  
- 高度な継承に関する2つの不都合  
・2つの不都合、3つの心配  
　立場2として何を意識すべきか真剣に考えないなら、単にCharacterクラスを作って終わりにすることもできる  
　しかし、他の開発者への心配りを強く意識してCharacterのようなクラスを開発していると、2つの「不都合」に直面する。さらにその不都合を原因とする、さまざまな「心配事」も出てくる。「抽象クラス」や「インタフェース」は、これらの不都合や心配事を解決してくる道具なのである  
・最初の不都合  
　まず不都合Aを体験するために、実際にCharacterクラスを作成してみる  
　しかし、いざCharacterクラスを書こうとすると、attackメソッドのないように差し掛かったところで手が止まってしまうはずだ  
  
　public class Character {  
  　String name;  
  　int hp;  
  　// 逃げる  
  　public void run() {  
    　System.out.println(this.name + "は逃げ出した");  
  　}  
  　// 戦う  
  　public void attack(Matango m) {  
    　System.out.println(this.name + "の攻撃！");  
    　m.hp -= ??;  
    　System.out.println("敵に？？ポイントのダメージをあたえた！");  
  　}  
　}  
  
　なぜ手が止まってしまうのか。このCharacterクラスは将来、さまざまな開発者によって継承され、HeroやWizardやDancerなどを開発する際の材料として利用される。しかし、未来に完成するであろうHeroやWizard、そしてDancerは、それぞれお化けキノコを攻撃したときに与えるダメージが違うはずである。腕っぷしの強いHeroであれば与えるダメージは10ポイント、ひ弱なWizardなら5ポイント、さらに今は存在しないが、未来に追加されるかもしれない協力なキャラクターでは100ポイントなどもありえる。つまり、Characterクラスを造っている時点では、まだattackメソッドの内容を確定できないため、書きようがないのである  
  
　不都合A  
　継承の材料となるクラスを作る時点では、その処理内容をまだ確定できない詳細未定のメソッドが存在する  
  
・不都合Aに対する間違った解決方法  
　attackメソッドのような内容を確定できないメソッドを、どのように記述すればいいのか。まず考えつくのが、Characterクラスには、そもそもattackメソッドを記述しないという方法だ。HeroやWizardなどの新しいキャラクターのクラスを作成する時に、それぞれ継承先のクラスでattackメソッドを追加してもらう。しかし、この方法で不都合を解決しようとすると、他の開発者が将来、新しいキャラクターのクラスを作成する時に、もし継承先のクラスにattackメソッドを追加し忘れると「攻撃できないキャラクター」ができてしまう  
　そもそも、「現実世界(ゲームの世界)のすべてのキャラクターはHP属性を持ち、攻撃ができる」という前提でCharacterクラスを造り始めたのに、「attack()を持たないキャラクター」できてしまうのは困る。そもそもオブジェクト指向とは、「現実世界(今回の場合はゲームキャラクターたちが住む世界)を正確に写し取る」ことだ  
  「キャラクターであれば少なくとも攻撃ができるはず」というゲーム世界の前提を考えると、攻撃できないキャラクターが作れてしまう可能性は万が一にもあってはならない。Characterクラスは必ずattackメソッドを持っているべきである  
  
　現実世界に対応したメソッド定義の必要性  
　「現実世界の登場人物が持つ操作」であれば、クラスのメソッドも存在すべきである(仮に、メソッドの処理内容は確定困難であったとしても)  
  
・不都合Aに対する対応策と2つの心配事  
　不都合Aの対応策として、「Characterクラスのattackメソッドは内容を確定できないので、とりあえず空にしておこう」と思いつくかもしれない。他の開発者がattackメソッドを継承して、それぞれのキャラクターのクラスを作成する際に、その職業に最適なattackメソッドでオーバーライドしてもらうという考え方である  
　public void attack(Matango M) {  
　}  
   
 　しかし、Characterクラスを利用してくれる未来の開発者たちを思いやる気持ちが強いほど、次の2の心配事が頭をよぎるだろう  
　　第1の心配事：オーバーライド忘れ  
　　第2の心配事：「何もしない」と区別  
・第1の心配事：オーバーライドを忘れる  
　未来の開発者がHeroやWizardなど具体的な職業のクラスを作る際にattack()のオーバーライドを忘れてしまうと、重大な不具合に直結する。たとえば、Heroクラスでattackメソッドをオーバーライドし忘れたとする。Heroクラスは親クラスであるCharacterから内容が空のattackメソッドを受け継いでいる。そのため、ほかのメソッドからattack()メソッドを呼び出せるが、何も起きないという不具合を抱えたクラスになってしまう  
　解決策の1つとして、Characterクラスのattackメソッドを作成する時に、オーバーライドを忘れないようにコメントを残すという方法がある。しかし、Characterクラスを継承する未来の開発者が、このコメントを見逃したり無視したりする可能性は残る。仮に無視しなかったとしても、attack()と書いたつもりがatack()と書いてしまい、オーバーライドになっていないというミスが起きてしまう可能性がある  
・第2の心配事:「本当になにもしない」と区別がつかない  
　attackメソッドの中身を空にした時のコードの書き方は、「呼ばれても何もしない」メソッドを作りたい場合に行うものだ。しかし、今回のattack()は「何もしない」のではなく、「何をするかが未定で記述できない」のである。未来の開発者がこのメソッドを見た時に、「何もしないのが正しい」のか、それとも「何をするのか未定」なのか、区別がつかないおそれがある  
・第3の心配事:意図せずnewして利用されてしまう  
　第1と第2の心配事はCharacterクラスに関する心配事であった。つまり、「詳細未定のメソッド」に関係した心配事であったが、別の観点からの心配事もある。それは、未来の開発者が間違ってCharacterクラスをnewして利用してしまうかもしれないという心配だ。たとえば、プロジェクトに新しく入ったJava初心者Dさんに、「便利なクラスだから使って」とCharacterクラスを渡したら、Dさんは次のようなコードを書いてしまうかもしれない　　
　public class Main {  
  　public static void main(String[] args) {  
    　Character c = new Character();  
    　Matango m = new Matango();  
    　c.attack(m);  
  　}  
　}  
  
　Characterクラスから実体であるインスタンスが生み出されたり、そのインスタンスが仮想世界の中で活動してしまったりするのはかなり異常事態である。なぜなら、詳細なattackメソッドを含むCharacterクラスは、詳細未定につき、作りこんでいない部分が残っている未完成な設計図のようなものだからだ。Characterクラスに限らず、未来の開発者のために準備しておくクラスは、多かれ少なかれ未完成な部分が残っているものである。そのような設計図に基づいて、実体である製品(たとえば車)を生産して利用したら大変な事故に繋がることは容易に想像できる。そもそも、一部でも未完成部分が残っている設計図から、実体を生み出してはならないのである  
・第3の心配事の原因  
　なぜ、第3の心配事(間違ってnewされてしまう心配)がでてきてしまうのか。今まではあまり意識することはなかったが、そもそもクラスには2つの利用方法がある  
　　①newによる利用：インスタンスを生み出すためにそのクラスを利用する  
　　②extendsによる利用：一からクラスを開発すると効率が悪いので、あるクラスを継承元として利用する  
  
　HeroやWizardはnewするためのクラスとして、Characterはextendsするためのクラスとして、それぞれ開発されている。しかし、Characterクラスの作成者が「etendsして欲しい」と願っても、未来の開発者は、newによる利用とextendsによる利用のどちらも選べてしまう。そのため、Characterのような未完成なクラスが誤ってnewされてしまうという事態が起きてしまうのである。クラスには自由に選べる2つの利用方法があるという利点が、皮肉にも意図されずnewされてしまう心配事の原因になっているのである  
  
　不都合B  
　クラスには2つの利用方法(newによる利用、継承による利用)があり、開発者はそれを自由に選ぶことが出来る  
  
　このような過ちが起こらないように、第1の心配事と同様、ソースファイルの先頭にコメントを書くというアイデアも考えられる。それでも、コメントを読み落とされたり無視されたりする可能性がある  
  
- 抽象クラス
・詳細未定のメソッドを宣言  
　第2の心配事  　
　空のメソッドを作っておくと、「現時点で処理内容を確定できないメソッド」なのか「何もしないメソッド」なのか、区別がつかない  
  
　Javaには、「詳細未定のメソッド」を記述する専用の構文が準備されている  
  
　詳細未定のメソッド(抽象メソッド)を宣言  
　public abstract 戻り値の型 メソッド名(引数リスト);  
  
　abstract(アブストラクト)とは「抽象的」「あいまい」という意味の単語である。これをメソッド宣言につけると、attack()というメソッドは宣言すべきであるが、具体的にどう動くか、内容がどうなるかまでは現時点では確定できないので、メソッド内部の処理はここでは記載しない、という意思の表明になる  
　メソッドの処理内容は未定で記述できないわけだから、メソッド宣言の後ろにはブロック記号の{}さえ付けず、その変わりにセミコロンを書く。abstractキーワードが付けられたメソッドは、抽象メソッド(abstract method)と呼ばれる  
　空メソッドは「何もしないメソッド」、抽象メソッドは「現時点では何をするかを確定できないメソッド」として区別できる  
・未完成のためnewしてはいけないクラスの宣言  
　第3の心配事  
　未完成部分を含む継承専用のクラスを誤ってnewされる可能性がある  
  
　Javaでは、未完成部分(抽象メソッド)を1つでも含むクラスは、次の構文に従って宣言しなければならない  
  
　抽象メソッドを含むクラスの宣言  
　public abstract class クラス名 {  
　 :
  }  
  
　Javaのルールでは、抽象メソッドを含むクラスは必ずabstract付きのクラスにしなければならない。もし1行目のabstractを忘れてしまったらコンパイルエラーになる  
　このように、abstractが付いたクラスは特に抽象クラスと呼ばれる。Characterクラスを普通のクラスではなく抽象クラスとして宣言すると、次のような特殊な制約がかかる  
  
　抽象クラスの制約  
　抽象クラスは、newによるインスタンス化が禁止される  
  
　抽象クラスとして宣言されたCharacterをインスタンス化しようとするとコンパイルに失敗する。Characterのように継承の材料となるクラスの開発では、抽象クラスとして宣言すればよい  
　継承専用のクラスを抽象クラスとして宣言すれば、間違ってnewされることはない  
・オーバーライドの強制  
　第1の心配事  
　未来の開発者が、詳細未定のメソッドをオーバーライドし忘れる可能性がある  
  
 この心配事は、すでに解決している。Characterを継承してDanerを作る新人社員Dさんの立場になって考えてみる  
　public class Dancer extends Character {  
  
  　public void dance() {  
    　System.out.println(this.name + "は情熱的に踊った");  
  　}  
　}  
  
　Dさんは、Dancer特有の能力である「踊る」(dance)というメソッドの作成に気を取られてattack()のオーバーライドを忘れてしまった。しかし、このソースをコンパイルしようとすると、抽象メソッドをオーバーライドしなければならないという意味のエラーメッセージが表示され、コンパイルは失敗する  
  DancerクラスはCharacterクラスを親クラスとするので、Characterクラスが持つすべてのメンバを継承している。そして、親クラスから継承したメンバの中には、抽象メソッドattack()も含まれている。つまり、Dancerクラス事態のソースコードに抽象メソッドはなくても、親クラスから抽象メソッドを継承して持っている。抽象メソッドが1つでもある以上、Dancerクラスも抽象クラスにしなければコンパイルエラーが出る  
　このエラーに対処するには、次の2つの方法がある  
　　①Dancerクラスの宣言にabstractを付けて抽象クラスにする  
　　②Dancerクラス内部の「未完成部分」をすべて完成させる  
  
　①の方法で解決を図ればコンパイルエラーを消すことはできる。しかし、抽象クラスとなってしまったDancerはnewできないので、HeroやWizardのようにインスタンスを生み出すことはできない  
　DancerをHeroやWizardのようにインスタンス化して冒険できるクラスとして開発したいならば、残された選択肢は②だけになる。すなわちDancerクラスの中でattack()をオーバーライドし、未完成メソッドをすべて完成させればよい  
  
　public class Dancer extends Character {  
  　public void dance() {  
    　System.out.println(this.name + "は情熱的に踊った");  
  　}  
  　public void attack(Matango m) {  
    　System.out.println(this.name + "の攻撃");  
    　System.out.println("敵に3ポイントのダメージ");  
    　m.hp -= 3;  
  　}  
　}  
  
　このオーバーライドによって、その存在だけが宣言されていたattackメソッドの動作が決定された。このように、それまで未定だったメソッドの内容を確定することを、実装(implements)と表現する。上記のコードのDancerクラスは、すべてのメソッドの動作が実装されており「詳細未定」な部分は残っていない。よってabstractを付ける必要はない。Dancerはnewして使える通常のクラスになった。今回のDancerの例を振り返ってみると、抽象クラスはnewできないルールがJavaに備わっているため、あるメソッドを抽象メソッドとして宣言しておけば、未来の開発者にオーバーライドを強制できる(オーバーライドしないとnewして使えない)効果があると考えられる  
  
　以上で3つの心配事がすべて解決した。抽象クラスと抽象メソッドを用いて、未来の開発者が安全かつ便利に利用できる「継承の材料」となるクラスを開発できるようになった  
・多階層の抽象構造  
　そのクラスでは確定できない抽象メソッドについては、必要に応じて、その孫クラス、あるいは曾孫クラスでオーバーライドして内容を確定させてもよい。その代わり、すべての抽象メソッドを実査王しなければクラス宣言からabstractを外すことは許されず、つまり、newして利用することはできない  
　たとえば、さまざまなモンスターたちの親クラスとなるMonsterというクラスを考えてみる。Monsterクラスはattack()とrun()のメソッドを持っているが、モンスターによって、どう攻撃するか、どう逃げるかについては現時点ではわからない。よって、両方ともabstractが付いた抽象メソッドである。次に、もう少し具体的なMonsterを定義するとする。WalkingMonsterは「トコトコ走って」、FlyingMonsterは「バサバサ飛んで」逃げていくと決まれば、run()だけはオーバーライドして内容を実装できる。しかし、WalkingMonsterやFlyingMonsterにはまだ抽象メソッドが残っている。attack()の詳細が未定なので、これら2つのクラスは共に抽象でなければならず、クラス宣言からabstract宣言を外すことはできない。さらに、WalkingMonsterの子クラスとしてGoblinクラスを定義し、このクラスではattack()をオーバーライドすると、ここでやっと抽象メソッドがなくなる。Goblinクラスはabstract宣言を付ける必要はなくなり、通常のクラスとしてnewして利用可能になる。同様にFlyingMonsterの子クラスとしてDethBatを定義し、このクラスでattack()をオーバーライドすると抽象メソッドはなくなり、これもnewして利用できるようになる  
　このようなモンスターたちの継承ツリーを眺めると、継承が繰り返されるたびに内容が具体化していくのがわかる。Monsterというクラスは大変にあいまいで、「HPとMPがある」「詳細は未定だが攻撃と逃げることが出来る程度しか決められていんし。もう少し具体化したWalkingMonsterやFkyingMonsterでは、逃げる処理の内容が確定する。さらに具体化したGoblinやDethBatは、攻撃の方法も確定し、あいまいさがまったくない  
  
- インタフェース  
・継承階層を上に辿ると…  
　継承階層が下がっていくたびにクラスは具体化していき、最終的にはすべてのメソッドについて処理内容が実装されていく。今度は、階層を下から上に昇って行く  
　以下の条件に沿ってMonsterクラスの親クラスを作っていく  
　　①MonsterとCharacterの共通の親として先頭に参加する生き物(BattleCreature)を定義する。先頭に参加する生き物の中には、専守防衛的な生き物もいるかもしれないので、atack()は定義できない  
　　②BattleCreatureの親として生き物(Creature)を定義する。これは村人やお姫様のように戦闘に参加しない登場人物も含んでいるため、HPフィールドはあると限らないが、どのような生き物でも脅威から逃げるためのrun()は持っている  
  
　GoblinであればHP、MP、名前、攻撃力などのフィールドと、attack()やrun()、useItem()などの内容が確定した具体的なメソッドを備えているだろう。しかし、Creatureのようにあいまいになると攻撃力やuseItem()はおろか、名前さえも持っているとは限らない。最低でも逃げるためのrun()ぐらいは持っていることしか決められない  
　この例に限らず、正しく継承が用いられている継承ツリーを上へ辿ると、次のような現象が順に起こる  
　　①抽象メソッドが増える  
　　　存在するのは確かだが、内容は確定できないメソッド(抽象メソッド)が現れ始める  
　　②抽象メソッドやフィールドが減っていく  
　　　クラスに定義してある抽象メソッドやフィールドが減っていく  
  
　継承階層を上に辿るということは、どんどんあいまいなものになっていくことを意味する。クラスがあいまいになるにつれ、「どのような内部情報も持っているか(フィールド)」「どのような動きをするか(メソッド)」は、あやふやになり、決められなくなっていく  
・抽象クラスの特別扱い  
　継承階層を上に辿ると、上流クラスは全て抽象クラスになる。そして、Javaでは、次の条件を満たす、特に抽象度が高い抽象クラスを、インタフェース(interface)として特別に扱うことができる  
　インタフェースとして特別扱いできる2つの条件  
　①すべてのメソッドは抽象メソッドである  
　②基本的にフィールドを1つも持たない  
  
　public abstract class Creature {  
  　public abstract void run();  
　}  
  
　上記のクラスには抽象メソッドしかなく、フィールドもない。このまま抽象クラスとしておいてもいいが、次の構文を用いてインタフェースとして定義することも可能だ  
  
　インタフェースの宣言  
　　public interface インタフェース名 {  
　　　：  
　　}  
  
　以下はインタフェースとして宣言したCreatureである  
    
　public interface Creature {  
  　public abstract void run();  
　}  
  
　なお、「インタフェースに宣言されたメソッドは、自動的にpublicかつabstractになる」というルールがあるので、通常は次のように書く  
  
　public interface Creature {  
  　void run();  
　}  
・インタフェースの名前の由来  
　なぜ2つの条件を満たした抽象クラスに「インタフェース」という、まったく新しい別の名前がついているのか、その竜を探るため、次のインタフェースを見てみる  
  
　public interface CleaningService {  
  　Shirt washShirt(Shirt s);  
  　Towl washTowl(Towl t);  
  　Coat washCoat(Coat c);  
　}  
  
　このCleaningServiceはシャツとタオル、そしてコートを渡せば、それを洗って返してくれる。しかし布団やマフラーは扱っていない。また、すべてのメソッドは抽象メソッドであり、処理内容が記述されている。つまり、クリーニング店の内部で行われる詳細な洗い方については明らかにされていない。CleaningServiceインタフェースは、まるでクリーニング店の店頭メニューのようである  
　店頭メニューは、クリーニング店が「こういう仕事を受け付けますよ」と表明するためのものである。そしてお客さんはメニューを見て、「この仕事をお願いします」と依頼する  
　つまり、メニューは店とお客さんの接点(英語で「interface」という)の役割を果たしている  
・インタフェースの実装  
　CleaningServiceインタフェースが店頭メニューだとすれば、それを継承して次のように記述したKyotoCleaningShopクラスこそが「クリーニング店そのもの」といえる  
   
　public class KyotoCleaningShop implements CleaningService {  
  　String ownerName;    // 店主の名前  
  　String address;      // 住所  
  　String phone;        // 電話番号  
  　/* シャツを洗う */  
  　public Shirt washShirt(Shirt s) {  
    　// 大型洗濯機15分  
    　return s;  
  　}  
  　/* タオルを洗う */  
  　public Towl washTowl(Towl t) {  
    　// 大型洗濯機10分  
    　return t;  
  　}  
  　/* コートを洗う */  
  　public Coat washCoat(Coat c) {  
    　// ドライ20分  
    　return c;  
  　}  
　}  
  
　KyotoCleaningShopクラスの1行目にあるように、インタフェースを継承して子クラスを定義する場合はextendsではなくimplementsを使う。これを「CleaningServiceインタフェースを実装してKyotoCleaningShopを作る」などと表現する  
  
　インタフェースの実装  
　public class クラス名 implements インタフェース名 {  
　　：  
　}  
  
　インタフェースという名前であっても。「しょせんは抽象クラスみたいなもの」である。インタフェースで定義されたwashShirt()、washTowl()、washCoat()は、すべて抽象メソッドなので、子クラスであるKyotoCleaningShopで、それぞれオーバーライドしなければならない    
　全国チェーン店では、どの店でも同じ店頭メニューを使っていることがある。おそらく本社で作ったメニューを、すべての店で掲示しているのだろう  
　チェーン店とはいえ、京都店・大阪店・奈良店は別の店なので、それぞれの店が持つ設備や選択の手順もさまざまだろう。つまり、共通のCleaningServiceを実装していたとしても、個々の店のクラスが持つフィールドやメソッドの詳細は異なってもよい。しかし、このクリーニングチェーンの加盟店は、共通の店頭メニューを出している以上、どの店もシャツ・タオル・コートの洗濯はできる必要がある。個々の店のクラスは、CleaningServiceインタフェースで定められた抽象メソッドをオーバーライドして処理を実装する必要がある  
　このように考えると、あるインタフェースに複数のメソッドを定義しておくと、次のような2つの効果を生み出すと考えられる  
　①同じインタフェースをimplementsする複数の子クラスたちに、共通のメソッド群を実装するよう強制できる  
　②あるクラスがインタフェースを実装していれば、少なくともそのインタフェースが定めたメソッドは持っていると保証される  
  
・特別扱いされる理由  
　クリーニング店の例で見たように、インタフェースは「このようなメソッド群を持ち、このような引数を与えれば、このような結果を返す」という表面的な確約をするだけで、その内部実装(メソッドの処理動作)をいっさい定めていない。インタフェースが特別扱いされるのは、この「内部実装をいっさい定義しない」という性質があるからだ。この性質のおかげで、インタフェースでは特別に多重継承が許されている。多重継承は、あるクラスを作成する際に2つの親クラスを使うことが出来るとても便利な機能である。しかし、多重継承は誤用されやすく危険なので、Javaでは基本的に、クラスの多重継承は禁止された  
　多重継承を用いると、両方の親クラスから同じ名前でありながら異なる内容の2つのメソッドを継承してしまう現象が起こりえるため、混乱を招いてしまう。これが、2つのインタフェースからの多重継承であれば、両方から抽象メソッドを継承するので、これを必ず適した形でオーバーライドすることになる  
　そもそも多重継承が問題なのは、両方の親クラスから同じ名前でありながら異なる内容のメソッドを継承して衝突してしまうからだ。しかし、両方の親がインタフェースの場合、どちらもメソッドの内容をいっさい定めていないから、親から継承した2つの処理内容が衝突することは起こりえない  
  
　クラスにはないインタフェースの特権  
　異なる実装が衝突する問題が発生しないため、複数のインタフェースによる多重継承が認められている  
  
　インタフェースによる多重継承  
　public class クラス名 implements 親インタフェース1, 親インタフェース名1、 親インタフェース名2 {    
　　：  
　}  
  
・extendsとimplementsを同時に使う  
　クラス定義の際にextendsとimplementsの両方を同時に利用することもある  
  
　extendsとimplementsの両方を使ったクラスの定義  
　public class クラス名 extends 親クラス implements 親インタフェース名1, 親インタフェース名2, … {  
　　:  
　}  
  
　例えば、次のような使い方をする  
　public class Fool extends Character implements Human {  
  　// Characterからhpやnameなどのフィールドを継承している  
  　// Characterから継承した抽象メソッドattack()を実装  
  　public void attack(Matango m) {  
    　System.out.println(this.name + "は戦わずに遊んでいる");  
  　}  
  　// さらにHumanから継承した4つの抽象メソッドを実装  
  　public void talk() { /* … */ }  
  　public void watch() { /* … */ }  
  　public void hear() { /* … */ }  
  　public void run() { /* … */ }  
　}  
  
## 多態性  
- 多態性とは  
・開発をラクにする多態性  
　多態性(polymorphism)はオブジェクト指向プログラミングを三大機能の1つで、多態性やポリモーフィズムとも呼ばれることもある  
・多態性のイメージ  
　多態性のあいまいなイメージ  
　「あるものを、あえてザックリ捉える」ことで、さまざまなメリットを享受できる機能  
  
　ザックリ捉えるとは、例えば以下のような考え方である  
　　・厳密に言えばSuperHeroなんだけど、まぁザックリいえばHeroだよね  
　　・厳密に言えばGreatWizardなんだけど、まぁザックリいえばWizardだよね  
　　・厳密に言えばSlimeなんだけど、まぁザックリいえばMonsterだよね  
　このような捉え方をして、さまざまなメリットを享受しようというのが多態性という機能である  
・現実世界でザックリ捉えるメリット  
　ザックリ捉えることによるメリットは、私たちの日常生活にも多く見ることができる。例えば、レンタカーを借りて車を運転する場面を考えてみる。厳密にいえば初めて乗る車であるにもかかわらず、多くの人は問題なく運転できる。なぜ、初めての車なのに運転できるのかとドライバーに聞けば、おそらく次のような答えが返ってくるだろう。「まぁハンドルは右だし、右ペダルがアクセル、左がブレーキ。細かいところはあれこれ違うけど、まぁザックリみれば、どの車も同じだ。」  
　この人は高級車や軽自動車などでも問題なく運転できるだろう。当たり前と思うかもしれないが、ロボットだとしたら、内臓される運転制御プログラムには、無数の細かい設定が必要である。ロボットは、それぞれの車種について細かい条件を完全に把握している必要があり、かつ「把握してない車」操作できない。車に限らず、私たち人間は、世の中にあるものさまざまな複雑な物をザックリ捉えることによって、厳密には違うもの、似たようなものとして上手に利用している。この私たちが現実世界でラクするためにザックリと捉える方法をプログラムでも実現する機能こそ、オブジェクト指向三大機能の1つ、多態性である  
  
- ザックリ捉える方法  
・ザックリ捉えるための文法  
　多態性には専用の文法はなく、今まで何度も使ってきた「代入の文法」を使うことで、ザックリ捉えるができるようになる  
　例としてSuperHeroクラスを用いる。前提として、SuperHeroクラスは親クラスにHeroクラスを、さらに親クラスにCharacterクラスを持っている。通常、SuperHeroのインスタンスを生成して利用するには、次のような文を記述する  
　SuperHero h = new SuperHero();  
  
　次に、SuperHeroを「ザックリCharacterとして捉える」書き方  
　Character c = new SuperHero();   
  
　以前、「newするときは左辺と右辺に同じ型を書く」ことを学んだが、実は上記のように左辺と右辺の型を代えることもできる。今回の場合、左辺の型がCharacterに代わる。箱の中身のインスタンスは正真正銘のSuperHeroだが、箱の表面には「Characterです」と書かれている。従って、この変数cについては、以後、本当はSuperHeroインスタンスだが、Characterとして捉えて利用することになる。このように、多態性を活用するには、「箱の型」と「中身の型」の2つの型が関係する。そして、あるインスタンスの捉え方は、代入する変数の型(箱の型)で決まる  
・できる代入、できない代入  
　代入式は基本的に「左辺の型と右辺の型が異なる場合はエラー」になる。たとえば、String str = 1;がエラーになるのは当然だ。しかし、基本に従えば、Character c = new SuperHero();の左辺はCharacter型、右辺はSuperHero型なのでエラーになるはずである。代入が許される判断基準は絵を描いてみれば分かる。箱には「Characterです」と書いてあり、SuperHeroが入っている。そしてこの絵の内容は(厳密ではないが)嘘ではない。スーパーヒーローキャラクターもキャラクターの一種(SuperHero is-a Character)なので、「キャラクターが入っています」と書かれた箱に入っても矛盾はない。Javaでは、このように絵に描いてみて嘘にならないインスタンスの代入は許される  
・継承のもう1つの役割  
　前項で、絵に描いてみて嘘がないならば代入が可能なのはわかった。しかし、そもそも絵に嘘が含まれるか判断するには「○○○は△△△の一種である」という前提知識が必要だ。たとえば、私たちは「Heroの中で特に選ばれた者がSuperHeroである」(SuperHeroはHeroの一種である)という前提知識があるからこそ、嘘ではないと判断できた。しかし、、Javaには「何が何の一種か」という一般的な知識は備わっていない  
　そこでJavaは、extendsやimplementsを用いた継承関係にあるクラスについて、「片方のクラスは、他方のクラスの一種」(is-aの関係)であると判断する。言い換えれば、extendsやimplementsは開発者が「is-aの関係」をJavaに伝える手段でもある。そのため、私たち人間にとってはis-aの関係であっても、Javaの継承関係で2つのクラスが繋がっていなければ代入はできない  
・箱の型に抽象クラスを使う  
　仮にあらゆるものの親として、新たにLifeインタフェースを作ったとする。CharacterクラスもLifeインタフェースを実装するように変更したと仮定する。以前「抽象クラスやインタフェースはインスタンス化できない」と学んだので、Lifeインタフェースが定義されている場合、new Life()とすることはできない  
　しかし、インタフェースであるLifeはインスタンス生成のためには利用できないが、変数の型として使うことはできる  
  
　抽象クラスやインタフェースの型  
　　抽象クラスやインタフェースからインスタンスを生み出せないが、それらの型を利用することは可能  
  
- ザックリ捉えたものに命令を送る  
・捉え方の違いは使い方の違い  
　まったく同一である1つの存在に対して複数の異なる捉えることができる  
　捉え方によって方法が変わる  
　あいまいで抽象的なほど用途は限定され、具体的に捉えるほど用途が増えていく  
・呼び出せるメソッドの変化  
　この「捉え方が変わると利用方法が変わる」という現実世界の現象は、Java仮想世界でも再現されている  
　Character.java  
　　public abstract class Character {  
  　　String name;  
  　　int hp;  
  　　public void run() {  
    　　System.out.println(this.name + "は逃げ出した");  
  　　}  
  　　public abstract void attack(Matango m);  
　　}  
  
　Wizard.java  
　　public class Wizard extends Character {  
  　　int mp;  
  　　public void attack(Matango m) {  
    　　System.out.println(this.name + "の攻撃！");  
    　　System.out.println("敵に3ポイントのダメージ");  
    　　m.hp -= 3;  
  　　}  
  　　public void fireball(Matango m) {  
    　　System.out.println(this.name + "は火の玉を放った！");  
    　　System.out.println("敵に20ポイントのダメージ");  
    　　m.hp -= 20;  
    　　this.mp -= 5;  
  　　}  
　　}  
  
　Wizardは魔法使いとしてattack()やfireball()のメソッドを持っているので、インスタンス化すればattackさせたりfireballを使わせたりできる  
  
　Main.java  
　　public class Main {  
  　　public static void main(String[] args) {  
    　　Wizard w = new Wizard();  
    　　Matango m = new Matango();  
    　　w.name = "アサカ";  
    　　w.attack(m);  
    　　w.fireball(m);  
  　　}  
　　}  
  
　WizardはCharacterの一種なので、Character型変数に代入することが可能である。しかし、Character型に代入してfireballを呼び出そうとするとコンパイルエラーが発生する  
  
 Main.java(エラー)  
　　public class Main {  
  　　public static void main(String[] args) {  
    　　Wizard w = new Wizard();  
    　　Character c = w;  
    　　Matango m = new Matango();  
    　　c.name = "アサカ";  
    　　c.attack(m);  
    　　c.fireball(m);  
  　　}  
　　}  
  
　Character型の変数Cに格納されているとはいえ、箱の中身のインスタンスは正真正銘のWizardインスタンスである。そしてWizardならばfireballが使えるはずなのになぜコンパイルエラーが発生してしまうのか。character型の変数に代入するということは、中身のインスタンスを「なにかのキャラクター」程度にザックリ捉えることにほかならない。従って、箱の中身がWizardである事実を忘れてしまうのである  
  
　あいまいな型の箱にインスタンスを代入すると  
　　インスタンスをあいまいに捉えることになり、「厳密のは何型のインスタンスだったか」がわからなくなってしまう  
  
エラーが起きるコードの3行目で魔法使いを生み出しているが、4行目の代入をした習慣、箱cの中身がHeroなのかWizardなのか、別の職業のクラスなのか分からなくなってしまう。確実に言えるのは、この箱に入っているのは、キャラクター一種であることだけである。そのため、attack()が呼び出せてfireball()が呼び出せなかった理由は以下のようになる  
　・attack()が呼び出せた理由  
　　箱の中身がHeroでもWizardでも、Characterの一種であればattack()は継承して持っているはずだから(どんなキャラクターでも最低限、攻撃はできるはずだから)  
　・fireball()が呼び出せなかった理由  
　　箱の中身が、fireball()を持っていると職業とは限らないから(キャラクターでも火の玉を放てるとは限らないから)  
  
　私たちがこのインスタンスを「Character」と捉えている限り(character型の変数に入っている限り)、Characterならできる最低限のことしか命令できない。箱の中身のインスタンスがどんなに多くのメソッドを持っていても、外部からCharacterとして持つメソッドしか呼び出せないのである  
・メソッドを呼び出せた場合に動く処理  
　メソッドが呼び出せた場合の動きは以下のようになる  
　Monster.java  
　　public abstract class Monster {
  　　public void run(){
    　　System.out.println("モンスターは逃げ出した。");
  　　}
　　}
  
　Slime.java  
　　public class Slime extends Monster {  
  　　public void run() {  
    　　System.out.println("スライムはサササっと逃げ出した。");  
  　　}  
　　}  
  
　Main.java  
　　public class Main {  
  　　public static void main(String[] args) {  
    　　Slime s = new Slime(); Monster m = new Slime();  
    　　s.run(); m.run();  
  　　}  
　　}  
  
　実行すると、s.run()とm.run()の結果はMonster型の変数mのrun()を呼び出しているので、「モンスターは逃げ出した」と表示されると思うが、両方「スライムはサササっと逃げ出した」と表示される。変数sと変数mとは、箱の表面に書かれた「○○○です」という表記に違いがあるものの、両方とも中身はあくまでもスライムである。なので「逃げろ！」という命令が届きさえすれば、当然スライムが逃げる。つまり、Slimeのrun()が動作する。このように、実際に動くメソッドの中身はインスタンスの型(中身の型)によって決まる。インスタンスがどんな型の箱に入っているかは関係ない  
  
　「箱の型」と「中身の型」  
　　箱の型　どのメソッドを「呼べるか」を決定する  
　　中身の型　メソッドが呼ばれたら、「どう動くか」を決定する  
  
- 捉え方を変更する方法  
・捉え方を途中で変える  
　Character c = new Wizard();があると変数cに対してfireballメソッドを呼べなくなるが、どうしてもこのインスタンスにfireballを使わせたいという場面がまれにあるだろう。fireballを使えるようにするためには、変数cの中身をWizardであると捉え直す必要がある。そのためには、Wizard w = c;を追加して、インスタンスをWizard型変数に代入すればいいと想像がつく。しかし、コンパイラは基本的にプログラムを1行ずつ解釈し、翻訳しようとするので、このコードもWizard w = c;だけを見てコンパイルエラーにしてしまう  
　この行だけに着目すると、Character型の変数cに入っているのは、HeroやThiefの可能性もある。万が一、変数cの中身がHeroなのに、それを代入してしまったら、Wizard型の変数にHeroインスタンスが入っている嘘の構図になってしまう。このように、コンパイラは変数の中身が代入先の変数の型と一致するとは限らないと考え、失敗する可能性のある代入を拒否する  
　それでも、どうしても変数cの中身を強制的にとらえ直したい場合には、Wizard w = (Wizard) c;のように「キャスト演算子」を使って、強制的に支持する方法が想像つく。この指示ならコンパイラは文句を言わず、コンパイルを通してくれる。しかし、あいまいな型に入っている中身を厳密な型に代入するキャストはダウンキャスト(down cast)といわれ、失敗の危険が伴う  
・キャストの失敗  
　ダウンキャストは、代入が失敗する可能性を懸念してエラーを出すコンパイラに対し、代入をしても矛盾のある状態にはならないから、黙って代入しなさいと頭ごなしに型変換を実行させる命令だ。前節のコードではうまくいくが、Hero h = (Hero) c;の場合、コンパイルは成功するが、動作させると、代入しようとした瞬間にClassCastExceptionエラーが発生する。このエラーは、キャストによる強制代入の結果、「嘘の構図」になったので強制停止せざるを得なくなった、という意味のエラーである  
・インスタンスを代入可能かチェックする  
　ダウンキャストによるClassCastExpectionを確実に回避するには、キャストしても大丈夫かを判定しながらキャストする。Javaにはそのためのinstanceof演算子が用意されている  
  
　安全にキャストできるかを判定しつつ、キャストする  
　　変数 instanceof 型名 キャスト後格納変数名  
  
　次のようなコードで、変数cの中身を安全にSuperHero型の変数hに代入できる  
　　if (c instanceof SuperHero h) {  
　　　h.fly();  
　　}  
  
　また、キャストが可能か判定した上で、キャストの支持を別にしたい場合は、次のように記述する  
　　if (c instanceof SuperHero h) {  
　　　
  　　SuperHero h = (SuperHero)c;
    　h.fly();  
　　}  
  
- 多態性のメリット  
・同一視して配列を利用する  
　5人のキャラクター(Heroが2人、Theifが1人、Wizardが2人)が旅をするゲームがあるとする。この5人は1つのパーティーを組んでいる。彼らが宿屋に泊まり、HPを50ずつ回復するプログラムを書く場合、次のようになる  
　  Main.java  
　　　public class Main   
  　　　public static void main(String[] args) {  
    　　　Hero h1 = new Hero();  
    　　　Hero h2 = new Hero();  
    　　　Thief t1 = new Thief();  
    　　　Wizard w1 = new Wizard();  
    　　　Wizard w2 = new Wizard();  
    　　　// 冒険開始！  
    　　　// まず宿屋に泊まる  
    　　　h1.hp += 50;  
    　　　h2.hp += 50;  
    　　　t1.hp += 50;  
    　　　w1.hp += 50;  
    　　　w2.hp += 50;  
 　 　　}  
　　　}  
  
　このプログラムの宿泊処理(10~14行目)には、2つの課題がある  
　　①コードに重複が多い  
　　　それぞれのHPを50増やす処理が何度も登場し、煩雑な記述になっている。変数名を取り違える可能性もある  
　　②将来的多くの修正が必要  
　　　パーティーの人数が増えた場合、宿泊処理に行を追加する必要がある。また、インスタンス変数名が変更になったらコードを修正しなければならない  
　  
　しかし、多態性と配列を上手に組み合わせれば、この問題は解決する    
　　public class Main {  
  　　public static void main(String[] args) {  
    　　Character[] c = new Character[5];  
    　　c[0] = new Hero();  
    　　c[1] = new Hero();  
    　　c[2] = new Thief();  
    　　c[3] = new Wizard();  
    　　c[4] = new Wizard();  
    　// 宿屋に泊まる  
    　for (Character ch : c) {  
      　ch.hp += 50;
    　}  
  　}  
　}  
  
　このコードの3行目でCharacter配列を使っている。従来のやりかたでインスタンスを厳密にHeroやThiefとして扱おうとする限り、それらを一括しては扱えない
　しかし、それぞれをCharacterだとザックリ見なせば「どれもキャラクター」なので、5つのインスタンスをCharacter配列にまとめ、ループを回して一括で処理することも可能になる  
　・同一視してザックリとした引数を受け取る  
　　Hero.java  
　　　public class Hero extends Character {  
  　　　public void attack(Matango m) {　(お化けキノコ攻撃用)  
    　　　System.out.println(this.name + "の攻撃！");  
    　　　System.out.println("敵に10ポイントのダメージをあたえた！");  
    　　　m.hp -= 10;  
  　　　}  
  　　　public void attack(Goblin g) {　(ゴブリン攻撃用)  
    　　　System.out.println(this.name + "の攻撃！");  
    　　　System.out.println("敵に10ポイントのダメージをあたえた！");  
    　　　g.hp -= 10;  
  　　　}  
  　　　// 以下スライム用など続く  
　　　}  
  
　上記のコードは重複が多くメンテナンスが大変である。また、将来新たにモンスターが増えるたびにattackメソッドも増やさなければならない。そこで、attackメソッドを次のように修正する  
  
　Hero.java  
　　public class Hero extends Character {  
  　　public void attack(Monster m) {  
    　　System.out.println(this.name + "の攻撃！");  
    　　System.out.println("敵に10ポイントのダメージをあたえた！");  
    　　m.hp -= 10;  
  　　}  
　　}  
  
　2行目のattackメソッドを見ると、攻撃する相手は、ザックリ捉えてモンスターなら何でも受け付ける、という表明です。このようなattackメソッドであれば、Monsterクラスを継承しているSlimeやGoblin、そして将来登場するモンスターたちも攻撃することができる  
・ザックリ利用しても、ちゃんと動く  
　多態性の真価は、これまで学んだ次の2つを組み合わせた時に発揮される  
　　1.ザックリ捉えてまとめて扱う  
　　　厳密には異なるインスタンスをまとめて扱える  
　　2.メソッドの動作は中身の型に従う  
　　　格納された箱の型に関わらず自身の型のメソッドが動作する  
  
　　Main.java  
　　　public class Main {  
  　　　public static void main(String[] args) {  
    　　　Monster[] monsters = new Monster[3];  
    　　　monsters[0] = new Slime();  
    　　　monsters[1] = new Goblin();  
    　　　monsters[2] = new DeathBat();  
    　　　for (Monster m : monsters) {  
      　　　m.run();  
    　　　}  
  　　　}  
　　　}  
  
　　Slime.java  
　　　public class Slime extends Monster {  
  　　　public void run() {  
    　　　System.out.println("スライムは、体をうねらせて逃げ出した。");  
  　　　}  
　　　}  
  
　　Goblin.java  
　　　public class Goblin extends Monster {  
  　　　public void run() {  
    　　　System.out.println("ゴブリンは、腕をふって逃げ出した。");  
  　　　}  
　　　}  
  
　　DeathBat.java  
　　　public class DeathBat extends Monster {  
  　　　public void run() {  
    　　　System.out.println("地獄コウモリは、羽ばたいて逃げ出した。");  
  　　　}  
　　　}  
  
　Main.javaの7~9行目で、指示を出す側(メソッドを呼び出す側)は、それぞれのモンスターに対して同じように「とにかく逃げろ」と、いいかげんな指示を繰り返しているだけである。一方、モンスターたちは「逃げろ」と言われたら、きちんと独自の方法で逃げる。どう逃げるかは自分で理解していて、その方法(自分のクラスに定義されたrunメソッドの内容)を使って逃げる。
　このように、呼び出し側は相手を同一視し、同じように呼び出すのに、呼び出される側は、きちんと自分に決められた動きをする(同じ呼び出し方から、多数の異なる状態を生み出せる)という特性から「多態性」という名前が付けられている  
  
## カプセル化  
- カプセル化の目的とメリット  
・カプセル化とは  
　「カプセル化」とは、フィールドへの読み書きやメソッドの呼び出しを制限する機能の事だ。たとえば、「この機能は、Aクラスからは呼び出せるけど、Bクラスからは呼び出せない」「このフィールドの内容は、誰でも読めるけど、書き替えは禁止」といった制約を実現できる。現実世界で例えると、もし、自分の銀行口座に誰もが出し入れ可能だとしたら、自分が気付かない内にお金を引き出されてしまうかもしれない。他にも、登録された人しか立ち入れないように、塀に囲まれ、門には守衛がいる軍事施設など、私たちの周りでは「制限」が行われている例が多くある。不便ではあるが、この制限があるからこそ、次のようなメリットを享受できる  
　・悪意のある人が軍事施設に入り、ミサイルを発射してしまうことを防げる  
　・子供がうっかり軍事施設に入り、ミサイルを発射してしまうことを防げる  
　・万一、何者かがミサイルを発射した場合、登録された人に犯人を絞り込める  
　このように、情報へのアクセスや動作の実施について、「誰に何を許すか」を定めて制限することを、アクセス制御(access control)という。Javaにおけるカプセル化とは、大切な情報(フィールド)や操作(メソッド)にアクセス制御をかけることにより、悪意や間違いよるメンバの利用を防止し、想定しない利用が発生した時には、その原因箇所を特定しやすくするためのしくみである  
・アクセス制御されない怖さ  
　もし、カプセル化によるアクセス制御されないとしたらどうなるだろうか。RPGを例にすると、仮に、勇者がインスタンス化されるとHPが100に設定されるとする。敵との戦いでHPが減少し、0以下になったら死亡してゲームオーバーになる。Heroクラスを使ったゲームのテスト中に、一度もモンスターと戦っていないのに勇者のHPがマイナス100になっていることに気付いたとする。数万行もあるゲームプログラムを確認して突き止めた原因が、新人社員Aさんが開発したコードで、宿屋で休憩したらHPが100になるのに、-100となっていることを突き止めた  
　翌日、今度は冒険中にお城で会話をすると、なぜか勇者が理由もなく急死してゲームオーバーになる、という問題を見つけた。原因を調査したところ、またもやAさんの作ったコードの「王様クラス」に問題があることがわかった。会話が終わったら、bye()を呼ぶべきところが、die()になっているため、この問題が起きてしまったのだ  
　このような不具合はAさんの不注意やスキル不足がきっかけで起こったといえる。しかし、見方を変えれば、「HPを-100に設定できてしまうこと」や「王様が勇者を殺せてしまうこと」にも問題がある。もし、プログラムに次のようなアクセス制御が盛り込まれていれば、このような不具合は事前に見つかったはずである  
　　・Heroクラス以外からは勇者のhpフィールドに値を設定できない  
　　・dieメソッドを呼べるのはHeroクラスだけである  
　カプセル化は、このようなアクセス制御を実現し、想定外に発生する不具合を未然に防ぐためのしくみである 
- メンバに対するアクセス制御  
・4つのアクセス制御レベル  
　Javaでは、メンバ(フィールドおよびメソッド)に対してアクセス制御の設定を行うことができる。しかし、各クラスのメンバに「Aクラス、Dクラス、Rクラスからの利用は許す」「Bクラス、Zクラスからの利用は許す」のように細かく設定すると、とても手間がかかってしまうし、分かりにくい。そこで、4段階からアクセス制御のレベルを選ぶ仕組みになっている  
　制限が厳しい順に、private、package private、protected、publicとなる。privateを指定する時はprivateと記述し、アクセスを許可するのは自分自身のクラスのみである。package privateを指定する時は何も記述しない、アクセスを許可するのは自分と同じパッケージに属するクラスのみである。protectedを指定する時は、protectedと記述し、アクセスを許可するのは自分と同じパッケージに属するか、自分以外を継承した子クラスのみである。publicを指定する時は、publicと記述し、アクセスを許可するのは全てのクラスである  
　privateやpublicなどはアクセス修飾子(access modifier)と呼ばれ、フィールドやメソッド宣言の先頭に記述する
  
　フィールドのアクセス制御  
　　アクセス修飾子 フィールド宣言;  
　メソッドのアクセス制御  
　　アクセス修飾子 メソッド宣言 {…}  
  
・privateを利用する  
　前節の宿屋クラスでは、誤ってHeroクラスのhpフィールドに-100が設定されていた。Heroクラスを確認すると、本来、HPフィールドはattack()で2ずつ減り、sleep()で回復すればよいので、ほかのクラスから直接変更できる必要はない。そたがって、HPはprivateとなる。hpフィールドにprivateを指定すると、宿屋クラスのcheckInメソッドでは「hpフィールドはprivateなのでアクセスできない」というコンパイルエラーが発生するようになる。しかし、勇者のhpフィールドがいっさい変更できなくなるわけではない。privateなフィールドであっても、同じクラスのメソッドからであれば、thisを用いて読み書きすることができる。宿屋クラスのcheckInメソッドでは、勇者のHPフィールドに直接100を代入できない代わりに、sleepメソッドを呼び出すように修正すればよいのである  
　また、dieメソッドについても、王様など、他のクラスからむやみに呼びだされないようにprivateにする　　
・publicや  package privateを利用する  
　勇者は戦うのが仕事なので、いろいろなクラスからattack()を呼び出される可能性がある。従って、attack()はどのようなクラスからでも呼び出せるようにpublicを指定を付けたままにしておく   
　また、sleepメソッドからはpublicを外す。この場合、package privateを指定したと見なされ、同じパッケージに属するクラスからの呼び出しのみ可能になる。仮に、Heroクラスがrpg.charactersパッケージに属しているとすれば、他のパッケージに属するSlimeクラスなどからは利用できなくなる  
・アクセス修飾の定石  
　どのメンバに、どのアクセス修飾子を指定すべきか、Javaの文法では定められていない。アクセス修飾子は自由に指定できるので、一般的には、メンバの使われ方を開発者がよく考慮した上で、最適なものを選ぶべきである。しかし、ほとんどのケースで通用する基本のパターン(定石)がある  
　　メンバに関するアクセス修飾の定石  
　　　・フィールドはすべてprivate  
　　　・メソッドはすべてpublic  
  
　とりあえずは、このパターンに沿ってアクセス修飾を行う。その後、Heroクラスのdieメソッドのように、クラス内部だけで利用するメソッドのみをprivateに指定し直すような微調整すればよいのである  
  
- getterとsetter  
・メソッドを経由したフィールド操作  
　private指定されたフィールドは、ほかのクラスからはアクセスできなくなっている。しかし、外部のクラスからフィールドの値を変更は可能である。例えば、hpフィールドをprivate指定した時に、外部のクラスからattackメソッドを呼べばHPを2減らすことができ、sleepメソッドを呼べばHPを回復できる  
　hpフィールドの値を変化させるには、必ずattack()かsleep()を経由させなければならない。勇者のHPを増減するためには、このどちらかのメソッドを経由しなければならない。つまり、ほかのクラス(宿屋クラスや王様クラス)の開発者がバグを含んだコードを書いたとしても、勇者のHPを-100に設定することは不可能である  
　もし万が一、HPに異常な値が設定される不具合に直面しても、そのときはattack()かsleep()のどちらかの処理に間違いがあると簡単に予想できるから、不具合の修正もスムーズにできるだろう  
・フィールド値を取り出すだけのメソッド  
　HPクラスには名前を格納したnameフィールドというフィールドがある。勇者の名前は、さまざまな場面んで多くのクラスから利用できる  
  
　public class King {  
    public void talk(Hero h) {  
    　System.out.println("王様：ようこそ我が国へ、勇者" + h.name + "よ。");  
    　System.out.println("王様：長旅疲れたであろう。");  
    　System.out.println("王様：まずは城下町を見てくるとよい。ではまた会おう。");  
    　h.bye();  
    　/* … */  
  　}  
　}  
  
　しかし、Heroクラスの全フィールドをprivateに設定していると、ｋのKingクラスでは次のようなコンパイルエラーが発生してしまう  
　　name は Hero で private アクセスされます  
　Heroクラスのnameフィールドｈprivateであるため、Kingクラスからはその存在が「見えない」のである。このままでは毛様が勇者の名前を取得できず、名前も呼べない。そこで、HeroクラスにgetNmaeメソッドを追加して、王様が勇者の名前を知ることが出来るようにする  
　
　　public class Hero {
  　　private int hp;
  　　private String name;
  　　private Sword sword;

  　　public String getName(){
    　　return this.name;
  　　}
  　　public void bye() {
    　　System.out.println("勇者は別れを告げた");
  　　}
  　　private void die() {
    　　System.out.println(this.name + "は死んでしまった！");
    　　System.out.println("GAME OVERです。");
  　　}
  　　void sleep() {
    　　this.hp = 100;
    　　System.out.println(this.name + "は眠って回復した！");
 　 　}
　　  public void attack(Matango m) {
    　　System.out.println(this.name + "の攻撃！");
    　　/* … */
    　　System.out.println("お化けキノコ" + m.suffix + "から2ポイントの反撃を受けた");
    　　this.hp -= 2;
    　　if (this.hp <= 0 ) {
      　this.die();
    　}
  　}
  　　/* … */
　}
　そして、Kingクラスでは、nameフィールドにアクセスしている部分をgetNam()を呼び出すように、修正すれば完成である  
　このgetNameメソッドは、attaack、メソッドなどとは異なり、単にnameフィールドの中身を呼び出し元に返すだけの単純なメソッドである。このようなメソッドを総称getter(ゲッターメソッドという)   
・getterメソッドの書き方  
　ある特定のフィールド値を取り出すだけのメソッドは、すべてgetterメソッドという。このgetterメソッドの書き方にも定石がある  
　getterメソッドの定石  
　　public フィールドの型 getフィールド名() {  
　　　return this.フィールド名;  
　　}  
  
　メソッド名の最初の3文字「get」にし、それに続けて「フィールド名の先頭を大文字にしたもの」を付け加える。たとえば、フィールド名がnameならgetName()となる(例外として戻り値がboolean型の場合のみisXxxx()メソッド名にすることがある)。このメソッド名の付け方はJava開発者の間で常識になっている慣習である  
・フィールドに値を代入するだけのメソッド  
　getterメソッドとは逆に、ある特定のフィールドに指定された値を代入するだけのメソッドをsetter(セッター)メソッドという。setterメソッドも、その記述方法には定石がある  
　　setterメソッドの定石  
　　　public void setフィールド名(フィールドの型 任意の変数名) {  
　　　　this.フィールド名 = 任意の変数名;  
　　　}  
  
　* getterとsetterは、アクセサ(accessor)と総称される  
・getter/setterの存在価値  
　フィールドをprivateにして外部アクセスから守ったのに、getter/setterを用意して外部に開放したらprivateにした意味が無いとか感じるかもしれない。しかし、getterとsetterには次のようなメリットがある  
　  
　メリット1　Read Only、Write Onlyのフィールドを実現できる  
　　setterメソッドを削除すれば、フィールドを外部から読めるが書き換えられない(Read Only)フィールドにできる。実務でも、外部から自由に読めてもいいが変更されては困るフィールドが必要になる場面があり、その際に多用されるテクニックである。また、あまり使われないが、setterメソッドだけを準備して、外部から自由に書き換えできるが、読めない(Write Only)フィールドも作成可能である  
  
　メリット2　クラスの内部設計を自由に変更できる  
　　たとえば将来、何らかの理由で元もとあったフィールドの名前を変更したくなったとする。もしgetter/setterを準備せず、ほかのクラスから直接、そのフィールドを読み書きしていた場合、ほかのクラスのすべての開発者に「アクセスするフィールド名を変更してもらうお願い」をして回らなければならない  
　　一方、フィールド名を隠し、外部からはgetter/setter経由で読み書きしてもらうのならフィールドめいの変更は自由である。なぜなら、getterやsetterの内部でフィールドを使っている部分だけを修正すればよく、getフィールド名()やsetフィールド名()を呼び出しているほかの開発者には影響がないからだ  
  
　メリット3　フィールドへのアクセスを検査できる  
　　クラス外部からフィールドの値を書き換えるには、setterを使う必要が生じる。つまり、setterを実現せずに、フィールドを書き換えることは可能である。この事実を利用して、設定されようとしている値が妥当かをsetterで検査するのもJavaプログラミングの定石である(Rubyの単体テストのイメージ)
  
- クラスに対するアクセス制御  
・2つのアクセス制御レベル  
　メンバへのアクセス制御と同じく、あるクラス全体に対してアクセス制御を設定することができる。厳しくしたい時は、何も記述しなければ、package private　となり制限が厳しく、自分と同じパッケージに属するクラスだけアクセスを許可する。すべてのクラスにアクセスを許可したい時はpublicと記述することで、publicとなる  
　これまで、クラス宣言の前にはpublicを付けると丸暗記していたが、クラス宣言の先頭にpublicが無い場合、そのクラスは同一パッケージに属するクラスからのアクセスのみ許可される。ほかのパッケージに属するクラスからのアクセスが禁止されるわけだが、ほかのパッケージに属するクラスから、そのクラスのぞんざい自体が見えなくなると捉えられる。そのため、たっとえpublicが指定されたメソッドが存在していても、属するクラスがpackage privateならば、別バージョンのクラスからはそのメソッドを呼び出せなくなる  
・別バージョンのクラスから見えなくなってしまうpackage privateクラスだが、その変わりpublicクラスでは許可されない次の2つのことが許される  
  
　非publicクラスの特徴  
　　①クラスの名前はソースファイル名と異なってもよい  
　　②1つのソースファイルに複数のクラスを宣言してもよい  
　これまでは、「1つのファイルに1つのクラス」「ファイル名=クラス名」が原則だが、より正確には、「1つのファイルに1つのpublicクラス」「ファイル名=publicクラス名」というルールである。publicが付いていないクラスは、どのソースファイルにいくつ宣言されてもかまわない。なお、ソースファイルにpublicクラスが1つも含まれない場合、ソースファイル名は自由に決めることができる  
  
- カプセル化を支える考え方  
・メソッドでフィールドを保護する  
　外部から直接触られないよう、メソッドという殻(カプセル)によってフィールドが保護されているように見えることから、このしくみにはカプセル化(encapsulation)という名前が付いている。メソッドの処理内容は、プログラミング段階で決定し、一度コンパイルされればプログラム実行中に変化することは無い。一方、フィールドの値は、プログラムが動作する間に刻々と変化していく。そのため、動作中に異常な値になる危険性も十分にありえる。不具合の多くは、フィールドに予期しない値が入ってしまうために発現する。だからこそプログラムの不具合を減らすには、メソッドよりもフィールドを保護することが重要である  
　プログラムの不具合を防止するためには、どんどんカプセル化をしていくのが良い。適切にカプセル化されていれば、インスタンスは大切なフィールドを直接外部にさらすことなく、互いに公開したgetter/setterやその他のメソッドを呼び合いながら、安全に連携できる  
・カプセル化の本質  
　カプセル化は継承に比べると一見、地味に見えるが、カプセル化こそがオブジェクト指向の本質を支えている。オブジェクト指向の本質を振り返ると、システムやプログラムは、突き詰めれば現実世界における何らかの相互作用を自動化するためのものであった。そして、現実世界の登場人物たちの動きを、そっくりそのまま仮想世界に再現するのがオブジェクト指向の基本的な考え方である  
　では、このオブジェクト指向の世界において、バグや不具合とはいったい何だろうか。それは、すなわち次の状態に他ならない  
  
　不具合とは  
　　不具合とは、現実世界と仮想世界が食い違ってしまうことである  
  
　例えば、実際の勇者は元気なのに、ゲームではなぜかHPがマイナス100になっている状態や、実際の在庫数は800なのに、システムではなぜか80になっている状態が発生してしまうからバグなのである  
　しかし、カプセル化を使えば、どのように利用されても、フィールドに不正な値が入ってしまうことのない「現実の登場人物と矛盾しないクラス」を作ることができる。そして、その「現実の登場人物と矛盾しないクラス」を集めてプログラムを作れば、「現実世界と矛盾しないプログラム」になる、という考えがカプセル化の狙いである  
　継承や多態性に比べれば、カプセル化は比較的簡単で、文法や効果にも華やかさはない。しかし、現実世界を忠実にまねるというオブジェクト指向の本質と直結している、最も重要な位置付けにある機能の1つだといえる  
  
## Javaを支えるクラスたち  
- 


































