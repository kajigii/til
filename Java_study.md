# プログラムの書き方  

## Javaプログラム作成から実行までの手順  
- ファイルの作成  
  ・テキストエディタで新しいファイルを作成し、拡張子を.javaとして保存  
  ・クラス名はアルファベット大文字で始める  
- Javaファイルを開き、Javaプログラムを記述  
  ・1行目のpublic classの後はクラス名を記述する。Javaのルールとしてファイル名は「クラス名.java」にしなければならない  
  ・2行目のpublic static void main(String[] args) {}の{}内に入力した記述が出力される  
  ・コード例  
    public class MyProgram {  
  　 public static void main(String[] args) {  
  　　 System.out.println("Hello, World!");  
  　 }  
   }  
- コンパイル  
  ・ターミナルまたはコマンドプロンプトを開き、Javaファイルが保存されているディレクトリに移動する  
  ・javacコマンド(javac クラス名.java)を使用してJavaファイルをコンパイルする  
- 実行  
  ・コンパイルが成功したら、javaコマンド(java クラス名)を使用してプログラムを実行する  

## Java プロジェクトの基本構造  
- プログラムの骨格  
  ・{}で囲まれた部分をブロックと呼ぶ。外側のブロックをクラスブロック、内側のブロックをメソッドブロックと呼び、Javaのソースコードはこれらのブロックによる二重構造を持っている  
  ・ Javaの命令を書くのはメソッドブロックの内側
- コメントの記入  
  ・複数行コメント  
  　/* コメント本文(複数行でも可能) */  
  ・単一行コメント  
  　//コメント本文(行末まで)  
- mainメソッドの内容  
  ・プログラム実行時は、文は上から順に1行ずつ処理される  
  ・分の末尾には必ずセミコロン(;)を付ける  
  ・ ()に入力するのが文字の時は""で挟む、数字の時は不要  
- 変数宣言の文  
  ・変数を使う時は、まず「変数宣言の文」を使い変数を使う宣言をする必要がある  
  ・変数宣言の文  
  　型 変数名;  
例) int = age  
  ・変数を宣言するときに使える名前のことを識別子といい、アルファベットや数字、アンダースコア(_)、ドル記号($)などを組み合わせて作る。  
 　 注意)intやvoid、public、staticなどの予約語は変数として使えない。小文字から始まる名詞形の名前を付ける(複数の単語を繋げて変数にする場合、2つ目以降の単語を大文字にする)  
- データ型  
　分類　　型名　　　格納するデータ  
　整数　　byte　　　とても小さな整数(±約128)  
　　　　　short　　　小さな整数(±約3.2万)  
　　　　　int　　　　普通の整数(±約21億)  
　　　　　long　　　大きな整数(±約900京)  
　少数　　float　　　少しあいまいでもよい少数  
　　　　　double　　普通の少数  
　真偽値　boolean　 tureかfalse  
　文字　　char　　　 1つの文字  
　文字列　String　　 文字の並び  

　　・整数を格納したい場合、int型を使うことが多い  
　　・少数を格納したい場合、より厳密な計算が行えるdoubleを使うことが多い、金額の計算など誤差が許されない計算の時はfloatやdoubleを使わない  
　　・boolean型は、「YESかNOか」「本当か嘘か」などの二者択一の情報を代入する時に使う、肯定的な情報はtrue、否定的な情報はfalse  
　　・char型は全角/半角を問わず1文字だけ代入できる、String型は文字列(0文字以上の文字の集まり)を代入できる。文字データを記述する場合は引用符(')で、文字列データを記述する場合は二重引用符(")を使う  

- 変数の初期化  
・変数を宣言すると同時に値を代入することを、変数の初期化という  
　　型 変数名 = 代入するデータ;
例) int age = 22;  
- 定数の宣言
・finalを付けて宣言された変数は定数として扱われ、値は書き換えられない(定数名はすべて大文字を用いる)
　　final 型　定数名 = 初期値;
例) final double PI = 3.14;

## 式と演算子  
- リテラル  
・ソースコードに記述されている数値や文字列などの具体的な値をリテラルという  
- エスケープシーケンス  
・String型やchar型のリテラルを記述する際に、ときどき用いられるものをエスケープシーケンスという、¥記号とそれに続く1文字からなる表記
  Javaは2つの二重引用符に囲まれた部分を文字列リテラルと見なすから、文字列の途中で改行する時や、記号を画面に表示する時などに使う  
　表記　　意味  
　¥"　　　二重引用符記号(")  
　¥'　　　引用符記号(')  
　¥¥　　　円記号(¥)  
　¥n　　　改行(制御文字)  
- 命令実行の文  
・命令実行の文  
　呼び出す命令の名前(引数);  
例) System.out.println(message);  
- 画面に文字を表示する  
・改行せずに画面に文字を表示する  
　System.out.print(①);　　①には画面に表示したい値や指揮を指定する  
- 大きいほうの数値を代入する命令  
・2つの値を比較して大きい方の数値を代入する  
　int m = Math.max(①,②);　　①および②には比較したい値や式を指定する(代入する変数名はm以外の名前でも可)  
　例)int a = 5;  
　　 int b = 3;  
  　　 int m = Math.max(a,b);  
- 文字列を整数に変換する命令  
・文字列を整数を変換する  
　int n = Integer.parseInt(①);  
- 乱数を生み出して代入する命令  
・乱数を発生させる  
　int r = new java.utilRandom().nextInt(①);　　①には発生させる乱数の上限値(指定値事態を含まない)を指定する  
　①に10を指定するとrには0~9のいずれかが代入される  
-　キーボードから1行の入力を受け取る命令  
・キーボードから1行の文字列の入力を受け付ける  
　String s = new java.util.Scanner(System.in).nextLine();  
・キーボードから1つの整数の入力を受け付ける  
　int input = new java.util.Scanner(System.in).nextInt();  
　これらの文を実行すると、プログラムは一時停止し利用者がキーボードから文字を入力できるようになる。入力した内容が各変数に代入される  

## 条件分岐と繰り返し  
- 代表的な制御構造  
　順次　　　単純に次の文を実行する  
　分岐　　　条件によって違う文を実行する  
　繰り返し　条件が満たされるまで同じ分を繰り返す  
・分岐  if文  
　if (分岐条件) ｛  
　　条件成立のときに実行する処理  
  　} else {  
  　　条件不成立のときに実行する処理  
  　}  
・繰り返し　While文  
　while (繰り返しを続ける条件) {  
　　繰り返し実行する処理  
　}  
・制御構文  
　if文やwhile文のような制御構造を表す分のこと 、条件式とブロックで成り立つ  
　条件式　　分岐条件や繰り返しを続ける条件を示した式  
　ブロック　分岐や繰り返しで実行する一連の文の集まり  
- ブロックの書き方  
ブロックとは、複数の文をひとまとまりとして扱うためのもので、2のルールがある  
・ルール1　波カッコの省略  
　ブロックは波カッコで囲まれた部分を指しているが、内容が1文しかなければ、波カッコを省略できる(ミス防止のため、省略することは推奨されていない)  
・ルール2　ブロック内で宣言した変数の寿命  
　ブロック内で新たに変数を宣言することもできるが、ブロックで宣言した変数は、そのブロックが終わると同時に消滅する  
　変数が利用可能な場所の範囲をスコープという  
- 条件式の書き方  
　条件式とは、if分やwhile文で利用される式の1つで、「処理を分岐する条件」や「繰り返しを続ける」を表現するためのもの、条件式では関係演算子を使う  
・関係演算子  
演算子　意味  
==　　 左辺等辺が等しい  
!=　　　左辺等辺が異なる  
＞　　　左辺が右辺より大きい  
＜　　　右辺が左辺より小さい  
＞=　　左辺が右辺より大きいか等しい  
＜=　　左辺が右辺より小さいか等しい  
・文字列の比較  
　Javaもルール上、文字列は==では正しく比較できないので、次のように記述する  
　文字列型の変数.equals(比較相手の文字列)  
・論理演算子  
　「年齢が18歳以上、かつ5月生まれ」のように2つ以上の条件を組み合わせた条件式の時に使う  
演算子　　意味  
&&　　　かつ(両方の条件が満たされた場合にtrue)  
||　　　　または(どちらか片方の条件さえ満たされればtrue)  
!　　　　 もし~でないなら(直後の条件式や値のtrueとfalseを反転させる)  
- 分岐処理のバリエーション  
・3種類のif構文  
　①if-else構文  
　②ifのみの構文(falseの時は何もしない時)  
　③if-else if-else構文(falseの時にさらに別の条件で分岐したい時　この時最後のelseブロックの中身が空ならelseごと省略できる)  
・switch文による分岐  
　switch文にできる条件  
　①すべての条件式が==で左辺と右辺が一致するかを比較する式になっており、それ以外の>、<、!=などが使われていない  
　②比較する対象が整数(byte型、short型、int型のいずれか)、文字列(String型)または文字(char型)であり、少数や真偽値ではない  

　　　switch文の注意点  
　　　①switch文の直後には、条件式ではなく、変数名を書く  
　　　②case(「~の場合は」)の横には値を書き、その後ろには -> {条件内容}を記述する  
　　　③defalt -> {条件処理}の部分は、条件に合致しないときの処理が不要な場合は省略可能である  
　　　④caseやdefaltのブロックを{}で囲まず、break;で終わらせることもできるが、break；を書き忘れるとコンパイルエラーにはならず、すぐ下のcase文も続けて実行されてしまう  

- 繰り返し構文のバリエーション  
・2種類のwhile文  
　①ブロックを実行する前に条件式を評価する(while構文)  
　②ブロックを実行した後に条件式を評価する(do-while構文)  
　無条件に処理を行って、その後、条件によっては繰り返しをしたい時に使用  
　do {  
　　ブロック  
  　} while(条件式);  
  ＊while構文とdo-while構文の違いは、while文は条件式の判定がfalseだった場合は一度もブロックを実行しないが、do-while構文はブロックを実行した後に条件判定を行うため、最低でも一度はブロックを実行する  
・for文による繰り返し  
　「x回だけ繰り返す」のように繰り返しの回数が決まっている場合は、for文を使うとよりシンプルなコードになる  
　for (int i = 0; i < 10; i++) {・・・}  
　＊変数はiでなくてもいいが、3つとも同じものを使う、10のところに繰り返す回数を書けばその分繰り返す  
・for文の各部の意味  
　forに続くカッコの中は、セミコロンによって区切られた3つの部分(左から①初期化処理、②繰り返し条件、③繰り返し時処理)で構成されている  
　①初期化処理  
　forによる繰り返しの前に、最初に1回だけ実行される文。「何周目のループかを記録しておく変数」を定義する、この変数をループ変数という  
　②繰り返し条件  
　ブロックの内容を実行する前に評価される、ループを継続するか否かを判定する条件式。評価結果がtrueの間は、ブロックが繰り返し実行される  
　＊for文はwhile文と同じ前置判定の繰り返し構文なので、後置判定はできない  
　③繰り返し時処理  
　for文内のブロックを最後まで処理して、ブロックを閉じる波カッコまで到達した直後に自動的に実行される文。通常は、i++のようにループ変数の値を1だけ増やす分を書く  
・ループ変数  
　①ループ変数の名前は、iに限らず自由に決めることができるが、for文より前に宣言されている変数名は使えない  
　②ループ変数も通常の変数なので、ブロック内での計算や表示に使える  
　③for文を抜けるとループ変数は消失するので、ブロック外では利用不可能  
・複雑なfor文  
　for文の「①初期化処理」、「②繰り返し条件」、「③繰り返し時処理」の3つを工夫すると、より高度な繰り返しを実現できる  
　例)  
　①ループ変数を1からスタートする  
　for (int i = 1; i < 10; i++) {・・・}  
　②ループ変数を2ずつ増やす  
　for (int i = 0; i < 10; i += 2) {・・・}    
　③ループ変数を10から1ずつ1まで減らしていく  
　for (int i = 10; i > 0; i--) {・・・}  
　④ループ変数を初期化しない  
　for (; i < 10; i++) {・・・}  
　⑤繰り返し時の処理を行わない  
　for (int i = 0; i < 10;) {・・・}  

- 制御構文の応用  
・制御構造のネスト  
　分岐や繰り返しの制御構造は、その中に別の制御構造を含むことができる。このような多重構造を入れ子やネストという  
・繰り返しの中断  
　for文やwhile文を用いた繰り返しの中で、中断したい場合は、break文かcontinue文で中断ができる  
　①break文は、breakを囲んでいる最も内側の繰り返しブロックが即座に中断される。繰り返し自体を中断したい場合に使用  
　②continue文は、今の周回を中断して、同じ繰り返しの次の周回に進みたい場合に使用  
・無限ループ  
　無限ループは強制停止されない限り永久に繰り返しを続ける制御構造のこと  
　無限ループの作成方法  
　① while (true) {処理}   
　② for (;;) {処理}  

## 配列  
- 配列のメリット    
・配列  
　配列とは1つの種類の複数データを並び順で格納するデータ構造。配列の中には、変数のような箱が連続して並んでいて、その1つひとつを要素という。要素は通常の変数のように型を持ち、1つのデータを格納できる。配列内の各要素には0から始まる番号が付いていて、これを添え字という  
- 配列の書き方  
・配列の作成  
  ・配列変数の作成(宣言)  
　　要素の型[] 配列変数名  
　　例)　int[] scores;  
  　　　　 scores = new int[5];  
  ・並列変数の宣言と要素の作成と代入を同時に行う方法  
　　int[] scores = new int[5];  
  ・配列の要素数の取得  
　　配列変数名.length  
・配列の利用  
　配列のどの要素に値を出し入れするかを指定するためには、scores[1] = 10;のように添え字を用いる(配列scoresの先頭から2つ目の要素に10を代入をしている)  
・配列の初期化  
　変数の値を取り出す前には、必ず値を代入して初期化しなければならないが、配列の要素は自動的に初期化される  
・省略記法  
　・配列作成と初期化の省略記法  
　① 要素の型[] 配列変数名 =  
　　　　new 要素の型[] {値1, 値2, 値3, ・・・};   
　② 要素の型[] 配列変数名 =  {値1, 値2, 値3, ・・・};  
　例)  
　int[] scores1 = new int[] {20, 30, 40, 50, 80};  
　int[] scores2 = {20, 30, 40, 50, 80};  
- 配列のデータをまとめて扱う  
・配列とfor文  
　配列の添え字には0や2といった固定の値(リテラル)だけでなく、変数を指定することもできる  
  配列活用の定石  
　パターン1　ループによる全要素の利用  
　パターン2　ループによる集計  
　パターン3　添え字に対応した情報の利用  
・パターン1　ループによる全要素の利用  
　配列の最初から最後までの要素を順にアクセスするパターン  
　添え字にはループ変数を指定しているため、ループのたびに0→1→2→3→4と変化し、最初から最後までの要素を順にアクセスする  
　要素の数が変わったとしても、for文の記述には影響がない  
　forループで配列を回す  
　for(int i = 0; i < 配列変数名.length; i++) {  
　　配列変数名[i]を使った処理  
　}  
・パターン2　ループによる集計  
　ループに入る前に、集計結果を入れるための変数sumを0で初期化し、for文で葉入れるを回して要素を1つずつ足していく。ループが終了した段階で、変数sumには配列の全要素の値が合算されている  
　このパターンは合計や平均を求める集計の他に、ある条件と一致する要素の数を数えるカウント集計という処理にも使われる  
・パターン3　添え字に対応した情報の利用  
  配列の中に配列を指定することで、配列で指定された回数処理が行われる  
・拡張for文  
  Javaには、配列の要素を1つずつ取り出すループを書くための特殊なfor文(拡張for文)が準備されている  
  拡張for文では、ループが1周するたびに、「任意の変数名」に指定した変数に配列の要素の内容が格納されるため、ループ変数や配列の添え字を記述する必要がなくなる  
　拡張for文で配列を回す  
　for(要素の型 任意の変数名 : 配列変数名) {  
　　:  
　}  
- 配列の後片付け  
・ガベージコレクション  
　配列変数の寿命は変数の寿命と同じで、宣言したブロックが終了するまでだが、newで確保された要素はブロックが終了しても寿命は向かえない。その結果、配列はどの配列変数からも参照されない状態でメモリに残ってしまう。しかし、Javaにはガベージコレクションというしくみが常に動いていて、実行中のプログラムが生み出したメモリ上のゴミ(どの変数からも参照されなくなったメモリ領域)を自動的に探し出して片づけてくれる。  
・null  
　nullとは「何もない」という状態を表す値、参照型の変数に代入することができる。nullが代入されると、参照型の変数はどこにも参照しない状態になる。この参照しない状態にすることを「参照を切る」ともいう。どの変数からも指されないので、ガベージコレクションの対象になる  
・NullPointerException  
　nullを代入したコードはどこも参照していないがコンパイルは成功する。しかし、実行するとエラーとなりNullPointerExceptionと表示される  
　この例外は、nullが格納されている配列変数を利用しようとしたときに発生する  
- 多次元の配列  
・多次元配列とは
  ここまで学習してきた配列を1次元配列といい、1次元配列に縦の並びを加えると2次元配列になる  
　2次元配列は要素が縦横に並んだ表のようなもので、データを表のような形で扱いたい時に使用すると便利  
　2次元以上の配列を多次元配列という。業務システム開発では使う機会は少ないが、科学技術計算などではよく利用される  
　・2次元配列の宣言  
　　要素の型[][] 配列変数名 = new 要素の型 [行数] [列数];
　・2次元配列の要素の利用  
　　配列変数名[行の添え字][列の添え字]  

## メソッド  
- メソッドとは  
・メソッドを利用するメリット  
　・プログラムの見通しがよくなり、全体を把握しやすくなる  
　・機能単位に記述するため、修正範囲を限定できる  
　・同じ処理を1つのメソッドにまとめることで、作業効率が上がる  
・メソッドの定義  
　メソッドを作成することメソッドの定義という  
　メソッドの定義  
  public static void メソッド名() {  
  　メソッドが呼び出されたときの処理  
　}  
・メソッドの呼び出し  
　メソッドを使用することをメソッドの呼び出すという  
　メソッドの呼び出し  
　メソッド名()  
　以下のコードの場合、mainメソッドが開始され、mainメソッドの中に書かれたhello();でhelloメソッドを呼び出す  
　public class Main {  
   public static void main(String[] args) {  
     System.out.println("メソッドを呼び出します");  
     hello();  
     System.out.println("メソッドの呼び出しが終わりました");  
   }  
   public static void hello() {  
     System.out.println("湊さん、こんにちは");  
   }  
 }  
・mainメソッド以外からのメソッドの呼び出し  
　メソッドは、mainメソッド以外のメソッドからも呼び出すことができる。以下のコードの場合の処理の流れは、main()→methodA()→methodB()の順に実行される  
　public class Main {  
   public static void methodA() {  
     System.out.println("methodA");  
     methodB();  
   }  
   public static void methodB() {  
     System.out.println("methodB");  
   }  
   public static void main(String[] args) {  
     methodA();  
   }  
 }  
・メソッドにまつわる2つの立場  
　メソッドにまつわる2つの立場  
　立場1 メソッドを定義する立場  
　立場2 メソッドを呼び出す立場  
　メソッドを定義する人は、メソッドを呼び出す人のことを考えてメソッドを作成する必要がある。メソッド名をaaa()やkeisan()のような名前ではなく、hello()やsaveToFile()のような名前が望ましい  
- 引数の利用  
・引数とは  
　メソッドを呼び出す際に、呼び出し元から値を渡すことができる。このときに渡される値のことを引数という。呼び出されたメソッド側では、渡された値を受け取って処理に利用でき、引数には数値や文字列などを指定でき、その値や型、渡す引数の数は開発者が自由に決めることができる  
・1つの引数を渡す  
　メソッドを呼び出す際、()の中に値を入れておくと、その値が引数として呼び出される側のメソッドに渡される  
・複数の引数を渡す  
　引数として渡す値が複数ある場合、値をカンマで区切って使用する。また、値を受け取るメソッド側でも、受け取る変数をカンマで区切って宣言する。このとき、引数として渡される値と、メソッド側で宣言する変数の型と順番を合わせる必要がある。引数と変数の型が合致しない場合にはコンパイルエラーが発生する  
　public class Main {  
   public static void main(String[] args) {  
     add(100, 20);  
     add(200, 50);  
   }  
   // 複数の値を受け取るaddメソッド  
   public static void add(int x, int y) {  
     int ans = x + y;  
     System.out.println(x + "+" + y + "=" + ans);  
   }  
　}  
　・引数を利用したメソッドの定義  
　　public static void メソッド名(引数リスト) {  
     メソッドの処理  
　　}  
　・引数を利用したメソッドの呼び出し  
　　メソッド名(引数リスト)  
　 *値には、変数名を指定することもでき、複数の引数を渡すときはカンマで区切って指定する  
・仮引数と実引数  
　引数の内、メソッドに渡す値を実引数、メソッドが受け取る変数を仮引数と呼ぶ  
・変数のスコープとローカル変数  
　変数のスコープとは、その変数が利用できる有効範囲のこと  
　ブロック内で宣言された変数のスコープは、そのブロック内に限定される。このような変数の性質をローカル変数の独立性という  
　メソッド内で宣言した変数をローカル変数と呼び、仮引数もその一種である  
　ローカル変数は、その変数が属するメソッド内だけで有効な存在であって、別のメソッドに属する同盟のローカル変数とは別物  
- 戻り値の利用  
・戻り値とは  
　呼び出されたメソッドから、呼び出し元のメソッドへ値を返すことを値を戻す(または値を返す)という。また、呼び出される値のことを戻り値(または「返り値」)という  
　・戻り値を利用したメソッドの定義  
　　public static 戻り値の型 メソッド名(引数リスト) {  
　　　メソッドの処理  
　　　return 戻り値;  
　　}  
　メソッドブロックの最終行に登場したのはreturn文という。この文は、「return]の後ろに書かれた値を呼び出し元に戻す約w利を担っている。変数に入っている値を戻すには、return変数名;のように変数名を指定する。return 100;やreturn "hello";のようにリテラルを指定することもできる  
　メソッド名の左側は、「void」ではなく「戻り値の型」となっている。ここには、returnによって戻される値と同じ型を指定する。整数を戻す場合は「int」、文字列型を戻す場合は「String」、変数に入っている値を戻す場合は、その変数の方を書く。何も戻さない場合は「void」を指定する(voidは「何もない」という意味)  
・戻り値を受け取る  
　戻り値は引数と同様に、変数を用意して受け取る必要がある。受け取るには、メソッドの呼び出し元で次の構文を使用する  
　・戻り値を利用したメソッド呼び出し  
　　型 変数名 = メソッド名(引数リスト);  
　文に代入演算子「=」がある場合、常に右辺から先に評価されるので、まずはメソッドの呼び出しが実行される。呼び出されたメソッドがreturn文によって値を戻す場合、「メソッド名(引数リスト)」の部分は評価されて戻ってきた値に置き換わる。それによって、型 変数名 = メソッドの戻り値;という状態になり、戻り値が変数に代入される  
　・戻り値の例  
　　public class Main {  
  　　public static int add(int x, int y) {  
    　　int ans = x + y;  
    　　return ans;  
  　　}  
  　　public static void main(String[] args) {  
    　　int ans = add(100, 10);  
    　　System.out.println("100 + 10 = " + ans);  
  　　}  
　　}  
　　*よくある書き方の間違い  
　　1. add(100,10) = int ans;  
　　addを呼び出そうとして add(100,10) と書き、ansに代入しようと = int ans; と書いてしまうパターン。構文として間違っているためコンパイルエラーになる  
　　2. add(100,10);  
　　addを呼び出そうとして int ans = の部分を書き忘れてしまう。add()は正しく実行されて結果の110が戻ってきているが、呼び出し元で受け取っていないため、mainメソッド内で戻り値を利用できない  
・戻り値をそのまま使う  
　メソッドの戻り値を変数で受けずに、そのまま使うこともできる  
　public class Main {  
  　public static int add(int x, int y) {  
    　int ans = x + y;  
    　return ans;  
  　}  
  　public static void main(String[] args) {  
    　System.out.println(add(add(10, 20), add(30, 40)));  
  　}  
　}  
　addメソッドの呼び出しが3つある。add(10, 20)とadd(30, 40)が実行され、それぞれの結果である「30」と「70」が戻り値として呼び出し元に返される。これによりカッコの外側のaddメソッドは add(30,　70)という状態になる。そして、「30」と「70」の引数を持ってaddメソッドが再び呼び出され「100」が addメソッドより戻される。最終的に System.out.println(100); という状態になり、画面には「100」が表示される  
・return文の注意点  
　return文は値を戻すだけでなく、メソッドの終了も行う。そのため、return文の後に処理を書いても実行されない  
- オーバーロードの利用  
・類似する複数のメソッドを定義する  
　プログラムが大きくなてくると、「似たような処理を行うメソッドを複数作る」必要に迫られることがある。しかし、処理内容が似ているからといって、メソッドに同じ名前は付けられない。同じ名前のメソッドが複数あると、JVMはどれを実行してよいか判断できないのでコンパイルエラーになる  
　しかし、例外的に同じ名前のメソッドを複数定義する方法がある。同じ名前のメソッドを定義することをオーバーロード(overload)または多重定義という  
　public class Main {  
  　// 1つ目のaddメソッド  
  　public static int add(int x, int y) {  
    　return x + y;  
  　}  
  　// 2つ目のaddメソッド  
  　public static double add(double x, double y) {  
    　return x + y;  
  　}  
  　// 3つ目のaddメソッド  
  　public static String add(String x, String y) {  
    　return x + y;  
  　}  
  　public static void main(String[] args) {  
    　System.out.println(add(10, 20));  
                       　/* 1つ目のaddメソッドが呼び出される */  
    　System.out.println(add(3.5, 2.7));  
                       　/* 2つ目のaddメソッドが呼び出される */  
   　 System.out.println(add("Hello", "World"));  
  　}                    /* 3つ目のaddメソッドが呼び出される */  
　}  
　定義されている3つのaddメソッドの型を見ると、1つ目は「int, int」、2つ目は「double, double」、3つ目は「String, String」となっている  
　仮引数が異なれば同じ名前のメソッドを複数定義することが許される。同じ名前のメソッドが複数あったとしても、仮引数の型が異なれば、JVMが呼び出し元の引数(実引数)を見て、その引数の方に一致するメソッドを呼び出してくれる(仮引数の型だけでなく、個数が違う場合もオーバーロードできる)  
- 引数や戻り値に配列を用いる  
・引数に配列を用いる  
　メソッドの引数にはint型やString型などの変数だけでなく、配列も使うことができる  
・値渡しと参照渡し  
　引数として通常の変数を指定した場合、メソッドに渡されるのは変数ではなく、変数に入っている値が渡される(メソッドを呼び出した時点で変数に代入されている値が、メソッドの仮引数にコピーされる)。この値そのものが渡される呼び出しを値わたし(call by balue)という  
　・基本型の変数をメソッド呼び出しで渡すこと  
　　・呼び出し元の変数の内容が、呼び出し先の引数にコピーされる  
　　・呼び出し先で引数の内容を書き換えても、呼び出し元の変数は変化しない  
　・メソッドの呼び出しで基本型変数ではなく配列を渡した場合  
　　メソッド呼び出しの際にコピーされるのは、配列の内容ではなく配列の先頭要素のアドレスとなる  
　　例)  
　　int[] array = {1,2,3};  
　　printArray(array);  
　　  
　　printArrayメソッド内でarray[0]に100を代入したら、この要素が100に書き換わる。printArrayメソッドが終了した後、mainメソッド内でarray[0]を取り出したら100を取り出すことになる  
　　引数としてアドレスを渡すことを参照渡し(call by reference)というが、参照渡しを行うと呼び出し先で加えた変更が呼び出し元にも影響する  
　・配列メソッド呼び出しで渡すこと  
　　・呼び出し元の配列のアドレスが、呼び出し先の引数にコピーされる  
　　・呼び出し先で配列の実態を書き替えると、呼び出し元にも影響する  
・戻り値に配列を用いる  
　引数と同様に、戻り値に配列を使用することができる  
　return 戻り値;によって配列の先頭要素のアドレスがmainメソッドに戻される。mainメソッドでは、それを自身で宣言した配列変数に代入して、作成された配列を参照できるようになる  
・コマンドライン引数  
　mainメソッドは文字列配列を引数として受け取るように定義されている  
　Javaのプログラムを起動する際、さまざまな「追加情報」を指定して起動することができる。このプログラム起動時の追加情報をコマンドライン引数という  
　・コマンドライン引数を利用したJavaプログラムの起動  
　　Java プログラム名 引数リスト  
　　*引数リストは()で囲まずに、半角スペースで区切って入力する  
　・コマンドライン引数  
　　プログラム起動時に指定したコマンドライン引数が、JVMによって配列に変換されｍmainメソッド起動時に渡される  

## 複数クラスを用いた開発  
・1つのソースファイルによる開発  
　1つのソースファイルの中に含まれるメソッドの数が増えると、ソースコード全体を把握するのは難しくなり、開発しにくくなってしまう  
　Javaでは、1つのソースファイルにはすべてのメソッドを書くのではなく、複数のソースファイルに分割して記述できるしくみがある。複数のソースファイルに分けて開発するのは、複数のクラスに分けて開発すると捉えることもできる  
　たくさんのメソッドを複数のクラスに分けて記述すると、整理されて分かりやすくなるだけでなく、ファイルごとに開発を分担し、それぞれが並行して開発を進められる(分業しやすい)というメリットもある  
・計算機プログラムを分割しよう  
　以下のコードを2つのクラスに分割する(Calc.java)  
　public class Calc {  
  　public static void main(String[] args) {  
    　int a = 10; int b = 2;  
    　int total = tasu(a, b);  
    　int delta = hiku(a, b);  
    　System.out.println("足すと" + total + "、引くと" + delta);  
  　}  
  　public static int tasu(int a, int b) {  
    　return (a + b);  
  　}  
  　public static int hiku(int a, int b) {  
    　return (a - b);  
  　}  
　}  
　tasu()やhiku()の2つは数学的な計算処理をするメソッドで、main()はtasu()やhiku()を呼び出して画面に表示する役割を持つ、全体の流れをつかさどるメソッド。main()とそれ以外のメソッドを2つのクラスに分けて整理する  
　①計算処理メソッドを記述するためのソースファイルを作成する  
　　計算ロジックのメソッドを入れるソースファイルを作成する(CAlcLogic.java)  
　②tasu()とhiku()を移動する  
　　Calc.javaの中にあるtasu()とhiku()をCalcLogic.javaに移動する  
　　public class CalcLogic {  
  　　public static int tasu(int a, int b) {  
    　　return (a + b);  
  　　}  
  　　public static int hiku(int a, int b) {  
    　　return (a - b);  
  　　}  
　　}  
　③メインメソッド内の呼び出しを修正する  
　　メインメソッド内でtasu()やhiku()を呼び出そうとしているが、移動させたので呼び出せない。「CalcLogicのtasu()」「calcLogicのhiku()」のように明示的に所属を示す必要がある  
　　int total = CalcLogic.tasu(a, b);  
　　int delta = CalcLogic.hiku(a, b);  
　修正したCalc.java  
　public class Calc {  
  　public static void main(String[] args) {  
    　int a = 10; int b = 2;  
    　int total = CalcLogic.tasu(a, b);  
    　int delta = CalcLogic.hiku(a, b);  
    　System.out.println("足すと" + total + "、引くと" + delta);  
  　}  
　}  
- 複数クラスで構成されるプログラム  
・複数クラスのコンパイル  
　分割したプログラムはそれぞれをコンパイルする必要がある。複数のソースファイルをjavacコマンドでコンパイルするときは以下のように記述する(前節のファイルで例える)  
　javac Calc.java CalcLogic.java  
　コンパイルが終了すると、それぞれのソースファイルに対応したクラスファイルが作成される  
・Javaプログラムの完成品  
　通常のアプリケーションはファイルは1つだが、Javaで開発されたプログラムは「複数のクラスファイルの集まり」であることが多い(起動はダブルクリックではなく、javaコマンドで起動させる)。そのため、Javaプログラムを誰かに渡す、あるいは納品する場合は、複数のクラスファイルが入っているフォルダををまるごと「1つの完成品」として渡す  
・プログラムの実行方法  
　クラスフォルダが入ったファイルをまるごと受け取った場合は、クラス名を指定して実行する必要がある  
　java クラス名  
　JVMは起動時に指定されたクラスファイルの中にあるmainメソッドを呼び出してプログラムの実行を開始する。よって、Javaプログラムを実行する人は「渡された複数のクラスファイルのうち、mainメソッドが含まれているクラスの名前」を指定する必要がある。複数の完成クラスファイルを渡す場合は、「mainメソッドが含まれるクラス名」を伝える必要がある  
- パッケージを利用する  
・クラスが増えすぎた時  
　クラスの数が数百個になると管理が大変になる。Javaには、各クラスをパッケージ(packeage)と呼ばれるグループに所属させて、分類・管理できるしくみが準備されている  
　*main()の行数が増えたら複数メソッドに分割→メソッド数が増えたら複数クラスに分割→クラス数が増えたら複数パッケージに分割  
　・クラスをパッケージに所属させる  
　　packeage 所属させたいパッケージ名;
　　*packeage文はソースコードの先頭に記述する  
　前節の計算機プログラムの場合、packeage calcapp.main;やpackeage calcapp.logics;になる  
　*パッケージの中にパッケージを入れることは出来ず、パッケージに親子関係はない。また、どのパッケージにも所属していない状態を「無名パッケージに属している」または「デフォルトパッケージに属している」と表現する場合もある    
・パッケージを含むクラス名を指定する  
　パッケージはそれぞれ独立しているので、パッケージを指定しないでコンパイルをすると自分と同じパッケージに所属するクラスを呼び出そうとすると構文エラーが発生する  
　別のパッケージに所属しているクラスを利用するには、所属しているパッケージ名を添えたクラス名を指定する必要がある。あるクラスから別パッケージのクラスを利用する場合、「パッケージ名を頭に付けた完全なクラス名」を使う必要がある。この完全なクラス名のことを、完全限定クラス名や完全修飾クラス名(full qualifited class name)、または略してFQCNという  
  ・完全限定クラス名(FQCN)  
　　パッケージ名.クラス名  
・完全限定クラス名の入力を省略する  
　プログラムが大きくなったら、calcapp.calcapp.logics.CalcLogicのように長い完全限定クラス名(FQCN)を何度もコードの随所に入力する必要がでてくる。このような場合は、import文を使うことによって、FQCN入力の手間を軽減できる  
　・記述例  
　package calcapp.main;  
　import calcapp.logics.CalcLogic;  
  
　public class Calc {  
　　public static void main(String[] args) {  
　　　int a = 10; int b = 2;  
　　　int total = CalcLogic.tasu(a, b);  
　　　int delta = calcapp.logics.CalcLogic.hiku(a, b);  
　　　System.out.println("足すと" + total + "、引くと" + delta);  
　　}  
　}  
  
　このimport文では「このソースコードでCalcLogicという表記があったら、それはcalcapp.logics.CalcLogicのことだと解釈しなさい」という指示になる。頻繁に利用するクラスはimport文を使ってインポートしておくと、完全限定クラス名を毎回指定する必要がなくなる  
　・calcapp.logicsパッケージに所属するすべてのクラスをインポートしたい場合  
　　package calcapp.main;  
　　import calcapp.logics.*;  
  
　　public class Calc {  
  　　public static void main(String[] args) {  
    　　int a = 10; int b = 2;  
    　　int total = CalcLogic.tasu(a, b);  
    　　int delta = calcapp.logics.CalcLogic.hiku(a, b);  
    　　System.out.println("足すと" + total + "、引くと" + delta);  
  　　}  
　　}  
　*import calcapp.logics.*;と記述すると、calcapp.mainとcalcapp.logicsに所属するすべてのクラスを一度にインポートできない(「calcapp.main」と「calcapp.logics」、「calcapp」はまったく異なるパッケージであり、親子関係にないからである)。この指定では、calcappパッケージに所属するすべてのクラスがインポートされる  
　・calcapp.mainとcalcapp.logicsに所属するすべてのクラスをインポートしたい場合  
　　import calcapp.main.*;  
　　import calcapp.logics.*;  

- パッケージに属したクラスの実行方法  
・実行クラス名の正しい指定  
　パッケージを利用していない時は、「java クラス名」で実行できたが、パッケージを利用している時はコンパイルは出来るがエラーとなる(java クラス名ではデフォルトパッケージを実行しようとしているため)  
　・javaコマンドの正確な構文  
　　java 起動したいクラスの完全限定クラス名(FQCN)  
・クラス名だけでクラスファイルを探し出すためのしくみ  
　・クラスローダー  
　　JVMが内部に持っている機構のこと。クラスローダーは、完全限定名を指定されたら、その名前を持つクラスのクラスファイルをPC内から検索し、JVMに読み込んで利用利用可能にするという役割を担っている。JVMは使いたいクラス名を指定しているだけであって、クラスファイルが置いてあるフォルダの場所を指定していない。クラスローダーはクラスパス(classpath)と呼ばれるヒント情報を使って、目的のクラスファイルを探し出す。クラスパスとは、クラスローダーがクラスファイルを探す際に、見にいくべきフォルダの場所で、あらかじめ1つ以上のクラスパスを指定しておく  
・クラスパスの指定方法  
　クラスパスを指定する方法は以下の3つ  
　①起動時にjavaコマンドで指定する  
　　javaコマンドでJVMを起動する際に、-cpオプションまたは-classpathオプションで指定する方法  
　　java -cp c:¥work Calc  
　②検索場所をOSに登録しておく  
　　OSの「環境変数」という設定にクラスパスを登録しておくことができる。javaコマンドは、この環境変数を自動的に読み込んでクラスファイルの検索に利用する   
　③特に指定しない  
　　環境変数に指定がなく、-cpオプションの指定もない場合、通常はjavaコマンドが実行されたフォルダがクラスパスとなる。例)c:¥workでjavaコマンドを実行したら、c:¥workがクラスパスに設定される  
・クラスパスで指定できる対象  
　クラスパスとして指定することができるものは、以下の3つから選べる  
　①フォルダの場所  
　　クラスファイルが置かれているフォルダの場所(絶対パス)。例)「c:¥work」と指定すると、、workフォルダ内のクラスファイルが検索対象となる  
　②クラスファイルが入ったJARファイルやZIPファイル  
　　クラスファイルが入っているJARファイルやZIPファイルがあれば、そのファイルの場所(絶対パス)をクラスパスとして指定できる。クラスローダーは指定されたファイルの中を検索し、もしクラスファイルが見つかれば読みこむ。例)Calc.classが入ったcalcapp.jarというファイルがc:¥work¥jarsにある場合、「c:¥work¥jars¥calcapp.jar」をクラスパスに指定すると、Calc.classを読みこむことができる  
　③複数のフォルダ、JAR/ZIPファイル、それらの組み合わせ  
　　複数のフォルダやJARファイル、ZIPファイルをデリミタ文字で区切ってクラスパスに指定できる。デリミタ文字は、Windowsの場合はセミコロン(;)、macOSやLinuxの場合はコロン(:)。クラスローダーは、指定された場所を前から順に探す  
　・Windowsの例  
　　c:¥work;c:¥work¥jars¥calcapp.jar  
　・LinuxやmacOSの場合  
　　/var/javadev:/var/javadev/jars/calcapp.jar  
・クラスファイルの正しい配置  
　クラスローダーはクラスパスで指定されたフォルダを足しように、探しているファイルを調べる。このとき、次のようなルールでパッケージに属しているクラスファイルを探す  
　・パッケージに対するクラスローダーの動作  
　　パッケージx.y.zに属するクラスCが対象なら、「クラスパスで指定されたフォルダ¥x¥y¥z¥C.class」を探そうとする  
　パッケージに属したクラスファイルをクラスローダーに読み込んでもらうには、現在のクラスパスを基準として、パッケージ階層に対応したフォルダを作り、その中に必要なクラスファイルを配置しておく必要がある  
　例)c:¥workをクラスパスとする場合、コンパイルによって生成されたCalc.classとCalcLogic.classは次のようなフォルダを作成し、その中に配置しなければならない  
　　　Calc.class　　　　　→　　　c:¥work¥calcapp¥mainフォルダ  
　　　calcLogic.class　　→　　　c:¥work¥calcapp¥logicsフォルダ  
  
　・クラスファイルを適切なフォルダに置いた状態で実行した場合の読み込みの流れ  
　①JVMは起動させるクラス名(calcapp.main.Calc)を受け取る  
　②JVMはクラスローダーにcalcapp.main.Calcの読み込みを指示する  
　③クラスローダーはクラスパスを確認する  
　④クラスローダーは、クラスパスを基準として「calcapp」→「main」とフォルダを降りていき(c:¥work¥calcapp¥mainの中)、そこにCalc.classというファイルを発見する  
　⑤クラスローダーは発見したCalc.classを読み込む  
　⑥JVMは読み込んだCalcクラスのmainメソッドを実行する  
- 名前空間  
・パッケージを使うもう1つのメリット  
　パッケージには、クラスをグループ化して整理し、プログラムを分かりやすくする目的の他に自分が作るクラスに対して、開発者が自由に名前を付けられるようにする役割がある  
　大規模な開発現場では、複数の開発者が分担して各自が受け持ったクラスを開発する。このとき、それぞれの開発者が偶然「同じクラス名を使ってしまう」可能性が出てくる。この内容が異なる別々のクラスで同じ名前を取り合うことを「名前の衝突」という。異なるクラスで同じクラス名を使うと区別が付かなくなってしまうため、Javaではクラス名の衝突は原則として許されない。使うことができる名前の総量(名前空間)は限られていて、新しくクラスを作ると、そのクラス名は使えなくなり、使えるクラス名は減っていく  
　パッケージが異なれば同じクラス名を使うことができる。クラス名が同一でも、パッケージ名が異なれば完全限定クラス名(FQCN)が異なるので両者を区別できる。パッケージの利用によって、それぞれのパッケージの中ではクラス名を自由に決めることができる  
・パッケージ名の衝突を避ける方法  
　クラス名と同様にパッケージ名も同じ名前だと区別が付かなくなる。自社の開発プロジェクトなら、誰がどのようなパッケージ名を使うかを事前に決めておけば衝突は回避できる。しかし、他社のパッケージを利用する場合、パッケージ名が衝突しないように事前にコントロールするのは困難である  
　解決策して、Javaでは自分(自社)が保有するインターネットドメインを前後逆順にしたものから始まるパッケージ名の使用を推奨している。例)foo.example.comというインターネットドメインを取得している企業であれば、com.example.fooで始まるパッケージ名を使う  
  
# スッキリ納得 オブジェクト指向  
  
## オブジェクト指向をはじめよう  
- オブジェクト指向ことはじめ  
・オブジェクト指向プログラミングをマスターしよう  
　オブジェクト指向プログラミング(Object Oriented Programing = OPP)という考え方に従ってプログラムを書くと、大規模なプログラムもラムに開発することができるようになる
- オブジェクト指向の定義と効果
・オブジェクト指向の定義
　オブジェクト指向とは、ソフトウェアを開発するときに用いる部品化の考え方のこと  
・オブジェクト指向のメリット  
　オブジェクト指向の根底にある目的は、人間が内容を把握しやすいプログラム開発を実現するというものである。この考え方を利用した「賢い部品化」を行うと、把握しやすさが向上するほかにも次のようなメリットが生まれる  
　　・プログラムの変更が容易になる(柔軟性・保守性の向上)  
　　・プログラムの一部を簡単に利用できる(再利用性の向上)  
　しかし、javaを学び始めた段階では、上記のメリットは実感しにくい。現段階で抱くべきメリットは「ラクして、楽しく、良いものを作れる」となる  
- オブジェクト指向の全体像と本質  
・オブジェクト指向と現実世界  
　私たちが開発するプログラムやシステムの多くは、現実正解における何らかの活動を自動化するためのもの  
　　例)ATM = コンピュータが無かった頃には人間が行っていた作業(依頼の受付、残高の検査、引き出し、記帳、受け渡し)を機械に肩代わりさせている  
　このようにプログラムやシステムは、現実世界のある活動を人間に代わって機械にやらせるために作られるものであって、現実世界と無関係に単独で存在しているものは、ほとんどない  
・手続きプログラミングとの違い  
　手続きプログラミングとは、開発者が頭を捻り、コンピュータがどのように動けばいいかという手順を考え、プログラムの先頭から順番に命令として記述していく方法  
　オブジェクト指向で開発を行う場合、いきなりコードを書き始めることはせず、実現しようとする部分の「現実世界」を観察し、設計図を作成する。この設計図は、ITの知識がない人に見せても理解でき、設計図の中の登場人物や物1つひとつを部品と捉え、それを「クラス」というJavaにおける部品で記述していく  
・開発時に作るクラス、実行時に動くオブジェクト  
　開発時に作られたクラスは、プログラムとして実行されると、それぞれ仮想的な登場人物のオブジェクトとしてJVMの中にその存在が生み出される  
　ATMのプログラムの場合は、「仮想的な口座」「仮想的な受付」「仮想的な印刷担当」などが、コンピュータ(JVM)という「電子的な仮想世界」の中に作られ、現実世界をそっくりまねたJava仮想世界とでもいえるような世界を形成する  
・オブジェクト指向における開発者の役割  
　オブジェクト指向プログラミングにおいて、開発者は神様のような存在といえる。仮想世界にどんな登場人物や物を生み出し、それらをどのように連携させるかを決め、それぞれの部品を作っていく立場であるからである  
　手続き型のプログラミングのように「コンピュータが実行すべき手順を1行ずつ定める」のではなく、「オブジェクトをどう作るか、どのように連携させるか」を第一に意識しながら開発していく。このことが「オブジェクト指向プログラミング」という名前の由来になっている  
・オブジェクト指向の本質  
　問「なぜオブジェクト指向の考え方を使うと、大規模で複雑なプログラムも把握しやすくなり、その結果、ラクして楽しく良いものを作れるのか？」  
　答「私たち人間が慣れ親しみ、よく把握している現実世界をマネして作られたプログラムもまた、私たち人間にとって把握しやすいものだから」  
　さらに、オブジェクト指向には以下のメリットもある  
　　・プログラム開発時に、「手続きを想像して作る」必要はない。現実世界をお手本に、それをマネして作ればよい  
　　・現実世界の登場人物に変化があった場合、対応する部品(クラス)を修正、変換すれば簡単にプログラムを修正できる  
　このようなメリットは、「現実世界をマネる」からこそ生まれてくる。つまり、現実世界の登場人物たちを、コンピュータの中の仮想正解にオブジェクトとして再現し、現実世界と同じように連携して動くようにプログラムを作ることこそがオブジェクト指向の本質である  
- オブジェクトと責務  
・サッカーで考えるオブジェクト指向  
　手続き型とオブジェクト指向との違いをサッカーで比較  
　　手続き型の場合は、11名の選手に的確に指示を出して選手を動かし、相手チームからゴールを奪わなければならない。全選手の一挙手一投足に対して、すべての指示を細かく出す必要がある  
　　オブジェクト指向の場合は、1人ひとりの選手を部品と考え、それぞれの責務(役割や責任)を事前に割り当てられたクラスとして作る。試合が始まったら監督のすることはほとんどなく、仮想世界には、それぞれの選手オブジェクトが生み出され、あとは選手オブジェクト自身が自分の役割を果たしながら他のオブジェクトと連携して動いてくれる  
　それぞれの選手(クラス・オブジェクト)に、「この状況下で、どう行動すべきか」という責務をあらかじめプログラミングしていくため、試合中にそれぞれの選手の一挙手一投足まで支持する必要はなくなる  
　・責務の割り当て  
　　オブジェクト指向プログラミングでは、開発者はそれぞれの部品(クラス)に責務をプログラムとして書き込む  
・オブジェクトの姿  
　仮想世界で動くオブジェクトは、すべて何らかの責務を仮想世界の神様たる開発者から与えられる。たとえば、「サッカー選手」オブジェクトは「ボールを受けたら前に走る」「シュートする」など、あらかじめ設定された役割を果たす行動責任を負っている  
　同様に、ATMの「受付」オブジェクトの場合は、振り込み依頼を受けたら「口座」オブジェクトが管理する2つの口座間でお金を移動し、その結果を「印刷係」オブジェクトに渡してATM利用控えの印刷を依頼するという一連の流れが受付の行動責任となる。「口座」オブジェクトは、行動責任は負っていないが、「残高をしっかり覚えておく」という情報保持責任を負っている  
　このような「情報保持」と「行動」の責任を果たすために、それぞれのオブジェクトは属性と操作を持っている  
　【属性】 その登場人物に関する情報を覚えておく箱  
　【操作】 その登場人物が行う行動や動作の手順  
- オブジェクト指向の三大機能  
・三大機能とその位置付け  
　オブジェクト指向の三大機能  
　　継承:過去に作った部品を流用し、新しい部品を簡単に作れる機能   
　　多様性：似ている2つの部品を「同じようなもの」と見なし、「いいかげんに」利用できる  
　　カプセル化：属性や操作を、一部の相手からは利用禁止にする機能  
  
## インスタンスとクラス  













































